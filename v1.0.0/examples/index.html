<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example · MomentMatching.jl</title><meta name="title" content="Example · MomentMatching.jl"/><meta property="og:title" content="Example · MomentMatching.jl"/><meta property="twitter:title" content="Example · MomentMatching.jl"/><meta name="description" content="Documentation for MomentMatching.jl."/><meta property="og:description" content="Documentation for MomentMatching.jl."/><meta property="twitter:description" content="Documentation for MomentMatching.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MomentMatching.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MomentMatching.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Example</a><ul class="internal"><li><a class="tocitem" href="#Setting-up-the-problem"><span>Setting up the problem</span></a></li><li><a class="tocitem" href="#Example.Estimation"><span>Estimation</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Example.Inference"><span>Inference</span></a></li><li><a class="tocitem" href="#Example.Multi"><span>Multithreading and multiprocessing</span></a></li><li><a class="tocitem" href="#Other-useful-features"><span>Other useful features</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ZoltanRacz/MomentMatching.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ZoltanRacz/MomentMatching.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Example:-Estimating-an-AR(1)-process-with-noise"><a class="docs-heading-anchor" href="#Example:-Estimating-an-AR(1)-process-with-noise">Example: Estimating an AR(1) process with noise</a><a id="Example:-Estimating-an-AR(1)-process-with-noise-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Estimating-an-AR(1)-process-with-noise" title="Permalink"></a></h1><p>Consider a stochastic process that is a sum of an AR(1) process and a white noise as follows:</p><p class="math-container">\[\begin{align*}
y_{i,t} &amp;= z_{i,t} + \nu_{i,t}\\
z_{i,t} &amp;= \rho \cdot z_{i,t-1} + \varepsilon_{i,t},
\end{align*}\]</p><p>where</p><p class="math-container">\[ \varepsilon_{i,t} \sim \mathcal{N}(0,\sigma_\varepsilon^2) \qquad  \nu_{i,t} \sim \mathcal{N}(0,\sigma_\nu^2)\]</p><p>are i.i.d. shocks. The aim is to estimate parameters <span>$(\rho, \sigma_\varepsilon, \sigma_\nu)$</span> based on a set of moments <span>$\text{Var}(y_{t}), \text{Cov}(y_{t}, y_{t-1}), \text{Cov}(y_{t}, y_{t-2})$</span> computed from an observed sample of <span>$y_{i,t}$</span>s.</p><h2 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h2><p>Being about to run a structural estimation exercise, one usually already has a piece of code that given</p><ul><li>a guess for the estimated parameters;</li><li>(possibly) a set of other parameters that are treated as fixed;</li><li>(possibly) a draw of random shocks;</li><li>(possibly) a set of empty arrays (to avoid allocation while evaluating the function)</li></ul><p>can compute a set of counterfactual moments, which can then be compared to their empirical counterpart.</p><p>To utilize this package one has to wrap this objective function and its inputs into functions and abstract types defined within the package. This is shown below.</p><p>First, one needs to define an estimation mode:</p><pre><code class="language-julia hljs">struct AR1Estimation &lt;: EstimationMode
    &quot;mode-dependent prefix of filenames used for saving estimation results&quot;
    filename::String
end</code></pre><p>During the estimation, one needs to evaluate the objective function for each parameter guess. Passing invariant parameters to the objective function is possible via defining an auxiliary structure which has to be a subtype of <code>AuxiliaryParameters</code>. One also needs to write a corresponding function to generate a default auxiliary structure as shown below. In this case, we pass the dimensions of the simulated sample.</p><pre><code class="language-julia hljs">struct AR1AuxPar{T&lt;:Integer} &lt;: AuxiliaryParameters
    &quot;sample size of simulation&quot;
    Nsim::T
    &quot;number of time periods to simulate&quot;
    Tsim::T
    &quot;number of periods to discard for moment evaluation &quot;
    Tdis::T
end

AuxiliaryParameters(mode::AR1Estimation, modelname::String) = AR1AuxPar(10000, 200, 100)</code></pre><p>It is crucial that the same set of shocks are used during the parameter estimation, as otherwise convergence cannot be achieved in the local minimization phase (the sensitivity of results to different draws of shocks can be checked via bootstrapping, as explained later in the <a href="#Example.Inference"><code>Inference</code></a> section). This is again done by defining an appropriate subtype of an existing abstract type and a function generating a default container of shocks. In this case, one needs to draw a normal shock for <span>$\varepsilon$</span> and <span>$\nu$</span> for each <code>t</code> and <code>n</code>.</p><pre><code class="language-julia hljs">struct AR1PreShocks{S&lt;:AbstractFloat} &lt;: PredrawnShocks
    &quot;preallocated array for persistent shocks&quot;
    ϵs::Array{S,2}
    &quot;preallocated array for transitory shocks&quot;
    νs::Array{S,2}
end

function PredrawnShocks(mode::AR1Estimation, modelname::String, typemom::String,aux::AuxiliaryParameters)
    return AR1PreShocks(randn(aux.Nsim, aux.Tsim),
        randn(aux.Nsim, aux.Tsim))
end</code></pre><p>In order to compute the necessary moments of large samples, one often needs to populate large arrays with realized values (in our case, of <span>$y_{i,t}$</span>s). Creating separate containers for each guess for the parameter vector would be very costly, so instead this is done once before starting the estimation, and the data contained within will be repeatedly overwritten. </p><div class="admonition is-info" id="Note-c9ee2b38e729b24c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c9ee2b38e729b24c" title="Permalink"></a></header><div class="admonition-body"><p>When performing an estimation via parallel computing, these containers are internally generated separately for each thread, and hence data race is automatically avoided.</p></div></div><p>In this example, we will compute cross-sectional moments in each time period and take their time-average in the final step. Therefore, we need to keep track of <span>$z$</span> and <span>$y$</span> (together its first and second lags) and the already computed moments. Defining the structure of preallocated data follows a similar logic as the previous steps.</p><pre><code class="language-julia hljs">struct AR1PrealCont{S&lt;:AbstractFloat} &lt;: PreallocatedContainers
    z::Vector{S}
    y::Vector{S}
    ylag1::Vector{S}
    ylag2::Vector{S}
    mat::Array{S,2}
end

function PreallocatedContainers(mode::AR1Estimation, modelname::String, typemom::String,
 aux::AuxiliaryParameters)

    z = Vector{Float64}(undef, aux.Nsim)
    y = Vector{Float64}(undef, aux.Nsim)
    ylag1 = Vector{Float64}(undef, aux.Nsim)
    ylag2 = Vector{Float64}(undef, aux.Nsim)

    mat = Array{Float64}(undef, 3, aux.Tsim) # one row for each moment

    return AR1PrealCont(z, y, ylag1, ylag2, mat)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PreallocatedContainers</code></pre><p>Now we are in the position of constructing the objective function. This is done via writing a method for <code>MomentMatching.obj_mom!</code>, specializing it on the subtype <code>AR1Estimation</code> created before.</p><pre><code class="language-julia hljs">using Statistics
function MomentMatching.obj_mom!(mom::AbstractVector, momnorm::AbstractVector,
 mode::AR1Estimation, x::Array{Float64,1}, modelname::String, typemom::String,
  aux::AuxiliaryParameters, presh::PredrawnShocks, preal::PreallocatedContainers;
   saving_model::Bool=false, filename::String=&quot;&quot;)
    (ρ, σϵ, σν) = x

    for n in 1:aux.Nsim
        preal.z[n] = 0.0
    end
    for t in 1:aux.Tsim
        for n in 1:aux.Nsim
            preal.z[n] = ρ * preal.z[n] + σϵ * presh.ϵs[n, t]
            preal.y[n] = preal.z[n] + σν * presh.νs[n, t]
        end
        if t &gt; 2
            preal.mat[3, t] = cov(preal.y, preal.ylag2)
            copy!(preal.ylag2, preal.ylag1)
        end
        if t &gt; 1
            preal.mat[2, t] = cov(preal.y, preal.ylag1)
            copy!(preal.ylag1, preal.y)
        end
        preal.mat[1, t] = var(preal.y)
        copy!(preal.ylag1, preal.y)
    end

    mom[1] = mean(@view preal.mat[1, aux.Tdis:end])
    momnorm[1] = mom[1]

    mom[2] = mean(@view preal.mat[2, aux.Tdis:end])
    momnorm[2] = mom[2]

    mom[3] = mean(@view preal.mat[3, aux.Tdis:end])
    momnorm[3] = mom[3]

end</code></pre><p>We give the names and ranges of the targeted parameters by writing a method of <code>parambounds</code>. During the global phase of the estimation, the region within &#39;global&#39; bounds is searched. Violating &#39;hard&#39; bounds during the local phase induces a penalty to redirect the algorithm towards the allowed range.</p><pre><code class="language-julia hljs">function MomentMatching.parambounds(mode::AR1Estimation)
    full_labels    = [ &quot;ρ&quot;,  &quot;σϵ&quot;,  &quot;σν&quot;]
    full_lb_hard   = [ 0.0,   0.0,  0.0 ]
    full_lb_global = [ 0.0,   0.0,  0.0 ]
    full_ub_global = [ 1.0,   1.0,  1.0 ]
    full_ub_hard   = [ 1.0,   Inf,  Inf ]
    return full_labels, full_lb_hard, full_lb_global, full_ub_global, full_ub_hard
end</code></pre><p>Next, we specify which moments are targeted during the estimation. In an actual application, this function would most likely read in values from a dataset, but here we just give three arbitrary numbers for each moments.</p><pre><code class="language-julia hljs">function MomentMatching.datamoments(mode::AR1Estimation, typemom::String)
    momtrue = [0.8, 0.45, 0.4] # made up numbers

    mmomtrue = deepcopy(momtrue)

    return hcat(momtrue, mmomtrue)
end</code></pre><p>Finally, we name the targeted moments. The <code>momentnames</code> function has to return a <code>DataFrame</code> with two columns, where one targeted moment corresponds to one row. If the two moments have coinciding values in the first column, the corresponding results will be visualized together, as shown in section <a href="#Example.Estimation"><code>Estimation</code></a>.</p><pre><code class="language-julia hljs">using DataFrames
function MomentMatching.momentnames(mode::AR1Estimation, typemom::String)
    moments = fill(&quot;Cov(y_t,y_t-j)&quot;, 3)
    lags = string.(0:2)
    return DataFrame(Moment=moments, Lags=lags)
end</code></pre><div class="admonition is-info" id="Note-cd4158b93077c556"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-cd4158b93077c556" title="Permalink"></a></header><div class="admonition-body"><p>By default the deviation between data and model moments is obtained by rescaling the difference between the two with data means of each moment. For instance, if one targets the time-series of the cross-sectional skewness of the distribution of income growth, the differences in each year would be scaled by the time-series average of the cross-sectional skewness (clearly, if one targets just one moment the mean is the moment itself). The user can change this by writing a mode-specific <code>mdiff</code> function (see related code in <code>estimation.jl</code>).</p></div></div><p>To summarize, when applying this package for existing code, follow these steps:</p><ol><li>Set up an <code>EstimationMode</code> structure.</li><li>Write <code>EstimationMode</code>-specific auxiliary structures <code>AuxiliaryParameters</code> (for any input that stays constant all over the estimation), <code>PredrawnShocks</code> (for simulation noise) and <code>PreallocatedContainers</code> (containers which can be overwritten over the estimation) whenever relevant. These will be inputs of the objective function.</li><li>Set the bounds of the parameter space and the values of the moments to be matched by writing an <code>EstimationMode</code>-specific <code>MomentMatching.parambounds</code> and <code>MomentMatching.datamoments</code> functions. </li><li>Wrap the objective function within an appropriate method of <code>MomentMatching.obj_mom!</code>.</li></ol><h2 id="Example.Estimation"><a class="docs-heading-anchor" href="#Example.Estimation">Estimation</a><a id="Example.Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Example.Estimation" title="Permalink"></a></h2><p>After defining an estimation setup (see section <a href="#Example.Alternative"><code>Estimating alternative specifications</code></a> for more details on why this structure is useful) and a structure supplying numerical settings, one can perform the estimation as follows. After checking 100 points in the global phase, a local minimization takes place using the Nelder-Mead algorithm, started from the 10 global points with the lowest objective function values. </p><div class="admonition is-info" id="Note-624a01adef8f6313"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-624a01adef8f6313" title="Permalink"></a></header><div class="admonition-body"><p>In this example we use the default weighting matrix - which is the unitary matrix - but the user can change this by defining a a mode-specific <code>default_weight_matrix</code> function (see related code in <code>estimation.jl</code>) or by passing their preferred weighting matrix via the keyword argument <code>Wmat</code> to <code>estimation</code>.</p></div></div><pre><code class="language-julia hljs">using OptimizationOptimJL
setup = EstimationSetup(AR1Estimation(&quot;ar1estim&quot;), &quot;&quot;, &quot;&quot;)

npest = NumParMM(setup; Nglo=100, Nloc=10,
 local_opt_settings = (algorithm = NelderMead(), maxtime = 30.0))

est = estimation(setup; npmm=npest, saving=false);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Performing global stage...   2%|▌                        |  ETA: 0:02:46Performing global stage...  67%|████████████████▊        |  ETA: 0:00:02Performing global stage... 100%|█████████████████████████| Time: 0:00:04
Performing local stage...  20%|█████▎                    |  ETA: 0:00:37Performing local stage...  50%|█████████████             |  ETA: 0:00:16Performing local stage...  70%|██████████████████▎       |  ETA: 0:00:09Performing local stage... 100%|██████████████████████████| Time: 0:00:25</code></pre><p>The estimated parameters can be displayed as follows:</p><pre><code class="language-julia hljs">tableest(setup, est)</code></pre><div><div style = "float: left;"><span>3×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Variable</th><th style = "text-align: left;">Point estimate</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">ρ</td><td style = "text-align: right;">0.893</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">σϵ</td><td style = "text-align: right;">0.319</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">σν</td><td style = "text-align: right;">0.545</td></tr></tbody></table></div><p>The match with targeted moments can either be displayed as a table</p><pre><code class="language-julia hljs">tablemoms(setup, est)</code></pre><div><div style = "float: left;"><span>3×4 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Moment</th><th style = "text-align: left;">Lags</th><th style = "text-align: left;">Sample values</th><th style = "text-align: left;">Model values</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">Cov(y_t,y_t-j)</td><td style = "text-align: left;">0</td><td style = "text-align: right;">0.8</td><td style = "text-align: right;">0.8</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">Cov(y_t,y_t-j)</td><td style = "text-align: left;">1</td><td style = "text-align: right;">0.45</td><td style = "text-align: right;">0.45</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">Cov(y_t,y_t-j)</td><td style = "text-align: left;">2</td><td style = "text-align: right;">0.4</td><td style = "text-align: right;">0.4</td></tr></tbody></table></div><p>or visualized on a figure:</p><pre><code class="language-julia hljs">using Plots
fmoms(setup, est)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GKS: cannot open display - headless operation mode active</code></pre><p><img src="../fmoms.svg" alt/></p><p>As in this case 3 parameters were estimated based on 3 moments (and hence parameters are exactly identified), the resulting match is very close.</p><p>Results can be saved by setting <code>saving</code> equal to <code>true</code>. In this case <code>filename</code> specified in estimation mode will be used as suffix. The default saving path is <code>&quot;./saved/estimation_results/&quot;</code>. </p><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><p>When the objective function is highly non-linear, it is in general difficult to know if the obtained parameter estimate indeed corresponds to a global minimizer. One concern would be that the obtained local optimum is &#39;too local&#39;, i.e. its basin of attraction is too narrow. In this case the local optimum would be very sensitive to the respective initial point. To judge the accuracy of the estimated parameter vector, two heuristic methods are available in this package.</p><p>First, it is possible to visualize how the objective function depends on varying the parameter estimates one-at-a-time (keeping the other parameters constant), around the best point.</p><pre><code class="language-julia hljs">marg = marginal_fobj(setup, est, 17, fill(0.1, 3))
fmarg(setup, est, marg)</code></pre><p><img src="../fmarg.svg" alt/></p><p>Second, one can visualize how sensitive the corresponding parameter values are to the rank of the corresponding global or local point, with respect to their objective function values. This is informative on the sufficient number of global and local points.</p><p>Output from the global stage is available via the <code>global</code> keyword.</p><pre><code class="language-julia hljs">fsanity(setup, est, glob = true)</code></pre><p><img src="../fsanity_glo.svg" alt/></p><p>By default, results from the local stage are shown.</p><pre><code class="language-julia hljs">fsanity(setup, est)</code></pre><p><img src="../fsanity_loc.svg" alt/></p><h2 id="Example.Inference"><a class="docs-heading-anchor" href="#Example.Inference">Inference</a><a id="Example.Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Example.Inference" title="Permalink"></a></h2><h3 id="Parametric-Bootstrap"><a class="docs-heading-anchor" href="#Parametric-Bootstrap">Parametric Bootstrap</a><a id="Parametric-Bootstrap-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Bootstrap" title="Permalink"></a></h3><p>Even if the model is correctly specified, there are two reasons why parameters are estimated with an error:</p><ol><li>The targeted population moments are obtained from a finite sample.</li><li>If evaluating the objecting function involves uncertainty, the whole estimation procedure is conducted with one particular draw of shocks. This makes results potentially sensitive to this specific realization of shocks.</li></ol><p>One can gauge the joint effect of these forces on the precision of the estimates via parametric bootstrapping. </p><ul><li>First, using the obtained parameter estimates, <span>$N_{sample}$</span> independent samples are created to mimic the uncertainty in the data generating process. The targeted moments are then computed from each of these samples. Note that the size of the simulated samples have to coincide with the actual data sample which was used to compute the data moments.</li><li>Second, if computing the objective function involves random draws, <span>$N_{seed}$</span> number of different shocks are draws.</li></ul><p>Then for each pair of alternative moments and seeds, the local stage of the estimation is repeated starting from the best local point of the original estimation. The distribution of the resulting <span>$N_{sample} \cdot N_{seed}$</span> new estimates can then be used to generate confidence intervals.</p><pre><code class="language-julia hljs">Tdis = 20 # burn in
Tdata = 40 # true data length
Ndata = 500 # true sample size
Nsample = 15 # number of samples used for bootstrap
Nseed = 15 # number of shock simulations used for bootstrap
auxmomsim = AR1AuxPar(Ndata, Tdata + Tdis, Tdis)
boot = param_bootstrap_result(setup, est, auxmomsim, Nseed, Nsample, Ndata, saving=false);

fbootstrap(setup, est, boot)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Performing bootstrap...   1%|▎                           |  ETA: 0:12:47Performing bootstrap...   2%|▋                           |  ETA: 0:09:21Performing bootstrap...   3%|▉                           |  ETA: 0:08:44Performing bootstrap...   4%|█▎                          |  ETA: 0:08:08Performing bootstrap...   6%|█▋                          |  ETA: 0:07:46Performing bootstrap...   7%|██                          |  ETA: 0:07:35Performing bootstrap...   8%|██▍                         |  ETA: 0:07:19Performing bootstrap...  10%|██▊                         |  ETA: 0:07:09Performing bootstrap...  11%|███                         |  ETA: 0:07:03Performing bootstrap...  12%|███▍                        |  ETA: 0:06:55Performing bootstrap...  13%|███▋                        |  ETA: 0:06:49Performing bootstrap...  14%|████                        |  ETA: 0:06:39Performing bootstrap...  16%|████▍                       |  ETA: 0:06:32Performing bootstrap...  17%|████▊                       |  ETA: 0:06:24Performing bootstrap...  18%|█████                       |  ETA: 0:06:20Performing bootstrap...  19%|█████▍                      |  ETA: 0:06:13Performing bootstrap...  20%|█████▋                      |  ETA: 0:06:09Performing bootstrap...  21%|██████                      |  ETA: 0:06:03Performing bootstrap...  22%|██████▎                     |  ETA: 0:05:57Performing bootstrap...  24%|██████▋                     |  ETA: 0:05:51Performing bootstrap...  24%|██████▉                     |  ETA: 0:05:46Performing bootstrap...  29%|████████▏                   |  ETA: 0:05:25Performing bootstrap...  30%|████████▍                   |  ETA: 0:05:21Performing bootstrap...  31%|████████▊                   |  ETA: 0:05:15Performing bootstrap...  32%|█████████▏                  |  ETA: 0:05:08Performing bootstrap...  34%|█████████▌                  |  ETA: 0:05:02Performing bootstrap...  35%|█████████▉                  |  ETA: 0:04:56Performing bootstrap...  36%|██████████▎                 |  ETA: 0:04:50Performing bootstrap...  38%|██████████▋                 |  ETA: 0:04:43Performing bootstrap...  39%|██████████▉                 |  ETA: 0:04:39Performing bootstrap...  40%|███████████▎                |  ETA: 0:04:33Performing bootstrap...  41%|███████████▋                |  ETA: 0:04:26Performing bootstrap...  43%|████████████                |  ETA: 0:04:20Performing bootstrap...  44%|████████████▍               |  ETA: 0:04:14Performing bootstrap...  45%|████████████▋               |  ETA: 0:04:09Performing bootstrap...  46%|█████████████               |  ETA: 0:04:03Performing bootstrap...  48%|█████████████▍              |  ETA: 0:03:57Performing bootstrap...  49%|█████████████▊              |  ETA: 0:03:51Performing bootstrap...  50%|██████████████              |  ETA: 0:03:46Performing bootstrap...  51%|██████████████▎             |  ETA: 0:03:40Performing bootstrap...  52%|██████████████▋             |  ETA: 0:03:34Performing bootstrap...  54%|███████████████             |  ETA: 0:03:28Performing bootstrap...  55%|███████████████▍            |  ETA: 0:03:22Performing bootstrap...  56%|███████████████▊            |  ETA: 0:03:16Performing bootstrap...  58%|████████████████▏           |  ETA: 0:03:10Performing bootstrap...  59%|████████████████▌           |  ETA: 0:03:04Performing bootstrap...  60%|████████████████▉           |  ETA: 0:02:58Performing bootstrap...  62%|█████████████████▎          |  ETA: 0:02:52Performing bootstrap...  66%|██████████████████▌         |  ETA: 0:02:31Performing bootstrap...  68%|██████████████████▉         |  ETA: 0:02:25Performing bootstrap...  69%|███████████████████▎        |  ETA: 0:02:19Performing bootstrap...  70%|███████████████████▌        |  ETA: 0:02:15Performing bootstrap...  71%|███████████████████▉        |  ETA: 0:02:09Performing bootstrap...  72%|████████████████████▏       |  ETA: 0:02:05Performing bootstrap...  73%|████████████████████▌       |  ETA: 0:01:59Performing bootstrap...  74%|████████████████████▊       |  ETA: 0:01:55Performing bootstrap...  76%|█████████████████████▏      |  ETA: 0:01:49Performing bootstrap...  76%|█████████████████████▍      |  ETA: 0:01:45Performing bootstrap...  78%|█████████████████████▊      |  ETA: 0:01:39Performing bootstrap...  79%|██████████████████████▏     |  ETA: 0:01:33Performing bootstrap...  80%|██████████████████████▌     |  ETA: 0:01:27Performing bootstrap...  82%|██████████████████████▉     |  ETA: 0:01:21Performing bootstrap...  83%|███████████████████████▎    |  ETA: 0:01:15Performing bootstrap...  84%|███████████████████████▌    |  ETA: 0:01:11Performing bootstrap...  85%|███████████████████████▊    |  ETA: 0:01:07Performing bootstrap...  86%|████████████████████████▏   |  ETA: 0:01:01Performing bootstrap...  88%|████████████████████████▌   |  ETA: 0:00:55Performing bootstrap...  88%|████████████████████████▊   |  ETA: 0:00:51Performing bootstrap...  90%|█████████████████████████▏  |  ETA: 0:00:45Performing bootstrap...  91%|█████████████████████████▍  |  ETA: 0:00:42Performing bootstrap...  92%|█████████████████████████▊  |  ETA: 0:00:36Performing bootstrap...  93%|██████████████████████████  |  ETA: 0:00:32Performing bootstrap...  94%|██████████████████████████▍ |  ETA: 0:00:26Performing bootstrap...  96%|██████████████████████████▊ |  ETA: 0:00:20Performing bootstrap...  97%|███████████████████████████▏|  ETA: 0:00:14Performing bootstrap...  98%|███████████████████████████▍|  ETA: 0:00:10Performing bootstrap...  99%|███████████████████████████▊|  ETA: 0:00:04Performing bootstrap... 100%|████████████████████████████| Time: 0:07:21</code></pre><p><img src="../fbootstrap.svg" alt/></p><h2 id="Example.Multi"><a class="docs-heading-anchor" href="#Example.Multi">Multithreading and multiprocessing</a><a id="Example.Multi-1"></a><a class="docs-heading-anchor-permalink" href="#Example.Multi" title="Permalink"></a></h2><p>The global and local phases of the estimation procedure require evaluating the objective function at many points of the parameter space. In our package this task can be parallelized with multithreading (<code>Threads</code> module, distributes across cores within a process), multiprocessing (<code>Distributed</code> module, distributes across different processes) and/or a combination of the two (distributes across different processes and then across the cores within a process) by appropriately setting the structure <code>ComputationSettings</code>. To apply some given computational settings, one just need to pass it to the <code>estimation</code> function with the keyword argument <code>cs</code>. We describe below how to do this locally on one&#39;s computer and on a cluster.</p><h3 id="Local-parallelization"><a class="docs-heading-anchor" href="#Local-parallelization">Local parallelization</a><a id="Local-parallelization-1"></a><a class="docs-heading-anchor-permalink" href="#Local-parallelization" title="Permalink"></a></h3><h4 id="Multithreading"><a class="docs-heading-anchor" href="#Multithreading">Multithreading</a><a id="Multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading" title="Permalink"></a></h4><p>In this case the only relevant field in <code>ComputationSettings</code> is <code>num_tasks</code>. If for example we run</p><pre><code class="language-julia hljs">cs_1 = ComputationSettings(num_tasks=4)
est_1 = estimation(setup; npmm=npest, cs=cs_1, saving=false);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Performing global stage...   4%|█                        |  ETA: 0:00:02Performing global stage...  17%|████▎                    |  ETA: 0:00:01Performing global stage...  30%|███████▌                 |  ETA: 0:00:01Performing global stage...  43%|██████████▊              |  ETA: 0:00:01Performing global stage...  56%|██████████████           |  ETA: 0:00:00Performing global stage...  70%|█████████████████▌       |  ETA: 0:00:00Performing global stage...  84%|█████████████████████    |  ETA: 0:00:00Performing global stage...  98%|████████████████████████▌|  ETA: 0:00:00Performing global stage... 100%|█████████████████████████| Time: 0:00:00
Performing local stage...  20%|█████▎                    |  ETA: 0:00:46Performing local stage...  60%|███████████████▋          |  ETA: 0:00:13Performing local stage... 100%|██████████████████████████| Time: 0:00:23</code></pre><p>then in the global estimation phase, four tasks will be spawn, with each containing a quarter of all points where the objective function needs to be computed. These tasks are then queued at the available threads, the number of which depends on how Julia was started (as usual), in particular the option <code>-t/--threads</code> command line argument or  the <code>JULIA_NUM_THREADS</code> environment variable (see <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">here</a>). After the global phase is finished, the starting points for the local phase are also shared between 4 tasks.</p><div class="admonition is-info" id="Note-987039b120443f56"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-987039b120443f56" title="Permalink"></a></header><div class="admonition-body"><ul><li>Choosing a higher number for <code>num_tasks</code> than <code>JULIA_NUM_THREADS</code> and thus overscheduling the threads might help prevent idleness. </li><li>The default value for <code>num_tasks</code> is <code>Threads.nthreads()*2</code>, implying that multithreading is <strong>active by default</strong> and that threads are overscheduled.</li><li>Forcing single-threading is possible via setting <code>num_tasks</code> to 1.</li></ul></div></div><div class="admonition is-info" id="Note-ec784d7dcc4b1547"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ec784d7dcc4b1547" title="Permalink"></a></header><div class="admonition-body"><p>When using multithreading, separate <code>PreallocatedContainers</code> are spawn for each task, and the containers of estimation outputs are accessed elementwise, hence data races are prevented as long as no other object is being overwritten in the objective function written by the user.</p></div></div><h4 id="Multiprocessing"><a class="docs-heading-anchor" href="#Multiprocessing">Multiprocessing</a><a id="Multiprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Multiprocessing" title="Permalink"></a></h4><p>Given that memory is not shared across the different processes, before running any code using multiprocessing we need to make sure that the required elements (functions, packages, structures, types...) are loaded in each of them. The function to do that is <code>load_on_procs</code>. Specifically, one writes a Julia script dedicated to loading all the required elements and calls it in <code>load_on_procs</code> which takes care of running it in every process. In our case such file is called <code>minimalAR1.jl</code> and it basically loads the functions, packages, structures, types, etc. that we have used so far in this example (if you want to have a look, the script is available in the <code>test/examples</code> folder of the GitHub repository of the package). Be sure to specify the path correctly when calling <code>include</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Distributed
julia&gt; function MomentMatching.load_on_procs(mode::AR1Estimation)
    return @everywhere begin include(&quot;minimalAR1.jl&quot;) end
end</code></pre><p>Besides telling Julia what to run on each process when starting them, we also need to specify</p><ul><li>how many processes we want</li><li>with how many threads the new Julia instances should start</li></ul><p>via the <code>num_proc</code> and <code>num_threads</code> fields of the <code>ComputationalSettings</code> structure. Note that when multiprocessing is active, <code>num_tasks</code> will set the number of tasks per process.</p><p>For example,</p><ul><li><code>ComputationSettings(num_procs=8, num_threads=1, num_tasks=1)</code> starts 8 processes without any multithreading on each. At most 8 points can be evaluated at the same time.</li><li><code>ComputationSettings(num_procs=8, num_threads=4, num_tasks=8)</code> starts 8 processes with 4 threads and 8 tasks on each. On each process, 4 tasks can immediately be scheduled to threads immediately, while 4 other ones will wait. At most 32 points can be evaluated at the same time.</li></ul><div class="admonition is-info" id="Note-412f4ef7c12e58a3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-412f4ef7c12e58a3" title="Permalink"></a></header><div class="admonition-body"><p>When via the <code>estimation</code> function both the global and local phases are performed in one go, the same specified computational settings are applied to both. It is also possible to run each phase separately with its own computational settings (see the section <a href="#Example.Onlyone"><code>Only global or only local</code></a> the description of how to run the two stages separately). <code>ComputationSettings</code> also works in the function performing bootstrapping.</p></div></div><div class="admonition is-danger" id="Danger-631351ab74e072cc"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-631351ab74e072cc" title="Permalink"></a></header><div class="admonition-body"><p>While the package is designed in a way to prevent data races in the estimation and bootstrapping routines, it is always the user&#39;s responsibility to check that this does not happen in their own model. In addition, it is best to avoid applying multithreading in one&#39;s model code within <code>obj_mom!</code> if multithreading is already active when looping over points in the parameter space.</p></div></div><h3 id="Parallelization-on-a-cluster"><a class="docs-heading-anchor" href="#Parallelization-on-a-cluster">Parallelization on a cluster</a><a id="Parallelization-on-a-cluster-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelization-on-a-cluster" title="Permalink"></a></h3><p>Currently, our package works only on clusters using Slurm Workload Manager. This is an example on how to set <code>ComputationSettings</code> for running the estimation on Slurm:</p><pre><code class="language-julia-repl hljs">cs = ComputationSettings(location = &quot;slurm&quot;, 
num_procs = 16,
num_tasks = 8,
num_threads = 8,
maxmem = 70, 
clustermanager_settings = Dict(:A =&gt; &quot;x&quot;,
 :job_name =&gt; &quot;y&quot;,
 :nodes =&gt; &quot;4&quot;,
 :ntasks_per_node =&gt; &quot;4&quot;,
 :cpus_per_task =&gt; &quot;8&quot;,
 :exclusive =&gt; &quot;&quot;,
 :mem =&gt; &quot;90GB&quot;,
 :time =&gt; &quot;23:59:59&quot;,
 :partition =&gt; &quot;z&quot;))</code></pre><p>We have specified the following options:</p><ul><li><code>location = &quot;slurm&quot;</code> the computation should be run on Slurm manager</li><li><code>num_procs = 16</code> the total number of processes to be started (16 in this case). On Slurm this has to be equal to <code>:nodes * :ntasks_per_node</code></li><li><code>num_tasks = 8</code> the number of tasks per process</li><li><code>num_threads = 8</code> number of threads to be started in each Julia process. On Slurm this has to be equal to <code>:cpus_per_task</code> (see below)</li><li><code>maxmem = 70</code> specifies the level in GB where aggressive garbage collection is triggered, should be less than <code>:mem</code> (see below) to avoid using more than the allocated resources</li><li><code>clustermanager_settings</code> is a flexible <code>Dictionary</code> which passes the relevant options to Slurm. In this case we have specified:<ul><li><code>:A</code> the project account to be charged for the computational allocation requested</li><li><code>:job_name</code> the name of the job </li><li><code>:nodes</code> how many HPC nodes are to be used (4 in this case)</li><li><code>:ntasks_per_node</code> how many processes per node have to be started (4 in this case), must be less than the number of cores per node </li><li><code>:cpus_per_task</code> how many cores are to be used per process (8 in this case), must be less than number of cores on node</li><li><code>:exclusive</code> that the job allocation cannot share nodes with other running jobs</li><li><code>:mem</code> the total memory requested per node</li><li><code>:time</code> the total time requested</li><li><code>:partition</code> the name of the HPC partition to use</li></ul>See the Slurm <a href="https://slurm.schedmd.com/documentation.html">docs</a> for more details and options.</li></ul><p>Users can thus perform multiprocessing, multithreading and/or a combination of the two also on a cluster which uses Slurm by properly specifying these options. Including <code>ComputationSettings</code> defined in the way just explained in the <code>estimation</code> command will automatically ensure that the latter is run with Slurm.</p><div class="admonition is-info" id="Note-83e7383df79ad6c7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-83e7383df79ad6c7" title="Permalink"></a></header><div class="admonition-body"><p>The word <em>task</em> has different meanings in Slurm and in this package: in our package (in line with Julia terminology) it refers to the number of tasks for multithreading, while in Slurm it means the number of processes per node.</p></div></div><div class="admonition is-info" id="Note-2a61144e2dc74b5a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2a61144e2dc74b5a" title="Permalink"></a></header><div class="admonition-body"><p>Applying this package with different cluster managing systems than Slurm should be possible via a slight modification of the <code>Distributed.addprocs(cs::ComputationSettings)</code> function. Any related pull request is greatly appreciated!</p></div></div><div class="admonition is-info" id="Note-830d18f2b8bb3b3c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-830d18f2b8bb3b3c" title="Permalink"></a></header><div class="admonition-body"><ul><li>Hardware configuration and rules for Slurm options to be included might differ across HPCs. The user should make sure that the options conform with their specific case. </li><li>If on a cluster, it&#39;s important to remember to set up correctly the required environment by loading the packages and functions before running the estimation.</li><li>If one runs the code from an open Julia session in the HPC then the Slurm command called is <code>srun</code>. It should be possible to use also <code>sbatch</code> by writing a script that calls the code.</li></ul></div></div><div class="admonition is-success" id="Tip-2a3cff41dc05d613"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-2a3cff41dc05d613" title="Permalink"></a></header><div class="admonition-body"><p>The best combination of options to choose in <code>ComputationSettings</code> (both when running jobs locally and on HPC) depends on the specific model and computer configuration used. For instance, while setting up multiple processes enhances parallelization, initializing them also requires time. We encourage users to experiment different combinations to figure out which one is the best for their setting.</p></div></div><h2 id="Other-useful-features"><a class="docs-heading-anchor" href="#Other-useful-features">Other useful features</a><a id="Other-useful-features-1"></a><a class="docs-heading-anchor-permalink" href="#Other-useful-features" title="Permalink"></a></h2><h3 id="Example.Alternative"><a class="docs-heading-anchor" href="#Example.Alternative">Estimating alternative specifications</a><a id="Example.Alternative-1"></a><a class="docs-heading-anchor-permalink" href="#Example.Alternative" title="Permalink"></a></h3><p>The package allows easy estimation of alternative model specifications or using a different set of moments. For instance, imagine that we want to estimate the original model without the noise, i.e., <span>$\sigma_\nu=0$</span>, by targeting only the variance and the first-order autocovariance. The first step is to define appropriately the structure <code>EstimationSetup</code>:</p><pre><code class="language-julia hljs">setup_noise_off = EstimationSetup(AR1Estimation(&quot;ar1estim&quot;), &quot;noise_off&quot;, &quot;onlytwo&quot;);</code></pre><p>The first element is <code>EstimationMode</code> (as we had before, and we keep it the same since we are considering a restricted version of the original model), the second element is a string specifying how we want to call this restricted specification (<code>modelname</code>), and the latter is a string specifying how to call the set of moments to target (<code>typemom</code>). Note that these two strings were defined as empty in the case presented before.</p><div class="admonition is-info" id="Note-66b35c8f3658d20c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-66b35c8f3658d20c" title="Permalink"></a></header><div class="admonition-body"><p>The <code>modelname</code> and <code>typemom</code> strings will be automatically included in the names of saved files.</p></div></div><p>Then, one specifies which parameters have to be estimated (relative to the order specified in <code>parambounds</code>) with the function <code>indexvector</code>:</p><pre><code class="language-julia hljs">function MomentMatching.indexvector(mode::AR1Estimation, modelname::String)
    indexvec = fill(true, length(parambounds(mode)[1]))

    if modelname == &quot;noise_off&quot; # we do not estimate the noise variance (which is the third element in parambounds)
        indexvec[3] = false
    end

    return indexvec
end</code></pre><div class="admonition is-info" id="Note-3c07a296e6fb2f72"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3c07a296e6fb2f72" title="Permalink"></a></header><div class="admonition-body"><p>If <code>indexvector</code> is not specified by the user, the algorithm includes all the parameters in <code>parambounds</code>. </p></div></div><p>Similarly, the set of moments to be targeted can be specified by redefining <code>MomentMatching.datamoments</code> for different <code>typemom</code>:</p><pre><code class="language-julia hljs">function MomentMatching.datamoments(mode::AR1Estimation, typemom::String)
    momtrue = [0.8, 0.45, 0.4] # made up numbers

    mmomtrue = deepcopy(momtrue)

    if typemom == &quot;&quot;
        return hcat(momtrue, mmomtrue)
    elseif typemom == &quot;onlytwo&quot; # in this case only first two moments used
        return hcat(momtrue[1:2], mmomtrue[1:2])
    end
end</code></pre><p>In this case we target only the first two moments. Finally, we redefine also the objective function:</p><pre><code class="language-julia hljs">function MomentMatching.obj_mom!(mom::AbstractVector, momnorm::AbstractVector,
 mode::AR1Estimation, x::Array{Float64,1}, modelname::String, typemom::String,
  aux::AuxiliaryParameters, presh::PredrawnShocks, preal::PreallocatedContainers;
   saving_model::Bool=false, filename::String=&quot;&quot;)

    if modelname == &quot;&quot;
        (ρ, σϵ, σν) = x
    elseif modelname == &quot;noise_off&quot; # we set the last parameter to zero
        (ρ, σϵ, σν) = vcat(x, 0.0)
    end

    for n in 1:aux.Nsim
        preal.z[n] = 0.0
    end
    for t in 1:aux.Tsim
        for n in 1:aux.Nsim
            preal.z[n] = ρ * preal.z[n] + σϵ * presh.ϵs[n, t]
            preal.y[n] = preal.z[n] + σν * presh.νs[n, t]
        end
        if t &gt; 2
            preal.mat[3, t] = cov(preal.y, preal.ylag2)
            copy!(preal.ylag2, preal.ylag1)
        end
        if t &gt; 1
            preal.mat[2, t] = cov(preal.y, preal.ylag1)
            copy!(preal.ylag1, preal.y)
        end
        preal.mat[1, t] = var(preal.y)
        copy!(preal.ylag1, preal.y)
    end

    mom[1] = mean(@view preal.mat[1, aux.Tdis:end])
    momnorm[1] = mom[1]

    mom[2] = mean(@view preal.mat[2, aux.Tdis:end])
    momnorm[2] = mom[2]

    if typemom == &quot;&quot; # this moment is needed only in the benchmark case
        mom[3] = mean(@view preal.mat[3, aux.Tdis:end])
        momnorm[3] = mom[3]
    end

end</code></pre><div class="admonition is-info" id="Note-f28c84350b2c1e25"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f28c84350b2c1e25" title="Permalink"></a></header><div class="admonition-body"><p>Besides the number of estimated parameters, <code>modelname</code> could also influence in which way the moments determined by <code>typemom</code> are computed, making more general robustness checks also easy to implement.</p></div></div><p>We also redefine the function to present the results: </p><pre><code class="language-julia hljs">function MomentMatching.momentnames(mode::AR1Estimation, typemom::String)
    moments = fill(&quot;Cov(y_t,y_t-j)&quot;, 3)
    lags = string.(0:2)
    if typemom == &quot;&quot;
        return DataFrame(Moment=moments, Lags=lags)
    elseif typemom == &quot;onlytwo&quot;
        return DataFrame(Moment=moments[1:2], Lags=lags[1:2])
    end
end</code></pre><div class="admonition is-info" id="Note-5d31d9118e7b683e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5d31d9118e7b683e" title="Permalink"></a></header><div class="admonition-body"><p>In a similar fashion, it is possible to make <code>modelname</code>- and <code>typemom</code>-specific also the auxiliary functions and the default matrix.</p></div></div><p>We are now ready to run the estimation of the restricted model: </p><pre><code class="language-julia hljs">est_noise_off = estimation(setup_noise_off; npmm=npest, saving=false);
tableest(setup_noise_off, est_noise_off)</code></pre><div><div style = "float: left;"><span>2×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Variable</th><th style = "text-align: left;">Point estimate</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">ρ</td><td style = "text-align: right;">0.562</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">σϵ</td><td style = "text-align: right;">0.74</td></tr></tbody></table></div><pre><code class="language-julia hljs">tablemoms(setup_noise_off, est_noise_off)</code></pre><div><div style = "float: left;"><span>2×4 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Moment</th><th style = "text-align: left;">Lags</th><th style = "text-align: left;">Sample values</th><th style = "text-align: left;">Model values</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">Cov(y_t,y_t-j)</td><td style = "text-align: left;">0</td><td style = "text-align: right;">0.8</td><td style = "text-align: right;">0.8</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">Cov(y_t,y_t-j)</td><td style = "text-align: left;">1</td><td style = "text-align: right;">0.45</td><td style = "text-align: right;">0.45</td></tr></tbody></table></div><p>Alternatively, one could also estimate the restricted model by targeting the original  three moments as follows. In this case the system is overidentified, and hence the moments cannot be matched exactly.</p><pre><code class="language-julia hljs">setup_noise_off_threemoments = EstimationSetup(AR1Estimation(&quot;ar1estim&quot;), &quot;noise_off&quot;, &quot;&quot;);
est_noise_off_threemoments = estimation(setup_noise_off_threemoments; npmm=npest, saving=false);
tableest(setup_noise_off_threemoments, est_noise_off_threemoments)</code></pre><div><div style = "float: left;"><span>2×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Variable</th><th style = "text-align: left;">Point estimate</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">ρ</td><td style = "text-align: right;">0.707</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">σϵ</td><td style = "text-align: right;">0.604</td></tr></tbody></table></div><pre><code class="language-julia hljs">tablemoms(setup_noise_off_threemoments, est_noise_off_threemoments)</code></pre><div><div style = "float: left;"><span>3×4 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Moment</th><th style = "text-align: left;">Lags</th><th style = "text-align: left;">Sample values</th><th style = "text-align: left;">Model values</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">Cov(y_t,y_t-j)</td><td style = "text-align: left;">0</td><td style = "text-align: right;">0.8</td><td style = "text-align: right;">0.728</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">Cov(y_t,y_t-j)</td><td style = "text-align: left;">1</td><td style = "text-align: right;">0.45</td><td style = "text-align: right;">0.515</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">Cov(y_t,y_t-j)</td><td style = "text-align: left;">2</td><td style = "text-align: right;">0.4</td><td style = "text-align: right;">0.364</td></tr></tbody></table></div><h3 id="Example.Onlyone"><a class="docs-heading-anchor" href="#Example.Onlyone">Only global or only local</a><a id="Example.Onlyone-1"></a><a class="docs-heading-anchor-permalink" href="#Example.Onlyone" title="Permalink"></a></h3><p>In the main example above both the global and local stages were performed in the same call. It is possible to perform only the global or only the local stage with the options <code>onlyglo</code> and <code>onlyloc</code> available in <code>NumParMM</code>: </p><pre><code class="language-julia hljs">npest_glo = NumParMM(setup; Nglo=100, onlyglo=true)
npest_loc = NumParMM(setup; onlyloc=true,local_opt_settings = (algorithm = NelderMead(), maxtime = 30.0))

est_glo = estimation(setup; npmm=npest_glo, saving=false)
# use the best 10 global as starting points
est_loc = estimation(setup; npmm=npest_loc, xlocstart = est_glo.xglo[1:10], saving=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Performing global stage...   3%|▊                        |  ETA: 0:00:04Performing global stage...   8%|██                       |  ETA: 0:00:05Performing global stage...  14%|███▌                     |  ETA: 0:00:03Performing global stage...  30%|███████▌                 |  ETA: 0:00:02Performing global stage...  43%|██████████▊              |  ETA: 0:00:01Performing global stage...  56%|██████████████           |  ETA: 0:00:01Performing global stage...  69%|█████████████████▎       |  ETA: 0:00:00Performing global stage...  82%|████████████████████▌    |  ETA: 0:00:00Performing global stage...  95%|███████████████████████▊ |  ETA: 0:00:00Performing global stage... 100%|█████████████████████████| Time: 0:00:01
Performing local stage...  20%|█████▎                    |  ETA: 0:00:29Performing local stage...  40%|██████████▍               |  ETA: 0:00:18Performing local stage...  70%|██████████████████▎       |  ETA: 0:00:08Performing local stage...  90%|███████████████████████▍  |  ETA: 0:00:02Performing local stage... 100%|██████████████████████████| Time: 0:00:23</code></pre><p>Note that in this example results might differ slightly from the estimation above because new shocks have been drawn (and because of the low maximum time - for exemplificatory purposes - specified for the solver in the local stage). It is possible to draw the shocks once and then pass them across different calls of <code>estimation</code> with the <code>presh</code> option.</p><h3 id="Merging-results"><a class="docs-heading-anchor" href="#Merging-results">Merging results</a><a id="Merging-results-1"></a><a class="docs-heading-anchor-permalink" href="#Merging-results" title="Permalink"></a></h3><p>For very long estimation exercises it can be useful to split the evaluation of global and/or local points across different calls of <code>estimation</code> and save the results after each call (so that if something goes wrong one does not need to recompute everything from scratch). For instance, to evaluate 10000 global points one can call <code>estimation</code> four times, each time evaluating 2500 points and then saving the results in one merged file (choosing which global points to evaluate in a given parameter space can be achieved through the option <code>sobolinds</code> in <code>estimation</code>). The function to achieve this is <code>mergeglo</code>. Below an example with 100 global points evaluated with two calls:</p><pre><code class="language-julia hljs">npest_glo_batch1 = NumParMM(setup; sobolinds=1:50, onlyglo=true)
npest_glo_batch2 = NumParMM(setup; sobolinds=51:100, onlyglo=true)

est_batch1 = estimation(setup; npmm=npest_glo_batch1, saving=false)
est_batch2 = estimation(setup; npmm=npest_glo_batch2, saving=false)

estmerged = mergeglo(setup, [est_batch1, est_batch2]; saving=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Performing global stage...  12%|███                      |  ETA: 0:00:01Performing global stage...  96%|████████████████████████ |  ETA: 0:00:00Performing global stage... 100%|█████████████████████████| Time: 0:00:00
Performing global stage...  20%|█████                    |  ETA: 0:00:00Performing global stage...  48%|████████████             |  ETA: 0:00:00Performing global stage...  74%|██████████████████▌      |  ETA: 0:00:00Performing global stage... 100%|█████████████████████████| Time: 0:00:00</code></pre><p>In this case, the estimation results to be merged were already in memory when merging, but one can of course load any already saved estimation result (again, note that results might be different from previous estimations for the same reasons described before).</p><p>A similar procedure can be applied for the local stage with the function <code>mergeloc</code> (in this case the user needs to specify the starting points to be evaluated with the option <code>xlocstart</code> in <code>estimation</code>). Finally, the function <code>mergegloloc</code> allows to merge together separate global and local results.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 7 August 2025 22:14">Thursday 7 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
