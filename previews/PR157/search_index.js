var documenterSearchIndex = {"docs":
[{"location":"fragments/estimation/#Estimation","page":"Estimation","title":"Estimation","text":"","category":"section"},{"location":"fragments/estimation/#Model-setup","page":"Estimation","title":"Model setup","text":"","category":"section"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"The first step of the estimation routine is for the user to define her own model type through:","category":"page"},{"location":"fragments/estimation/#MomentMatching.EstimationSetup","page":"Estimation","title":"MomentMatching.EstimationSetup","text":"struct EstimationSetup{U<:EstimationMode}\n\nDescription\n\nStructure to store setup of matching moments estimation procedure.\n\nFields\n\nmode: Estimation mode.\nmodelname: Submethod for estimation. String encoding which parameters and how are estimated.\ntypemom: Submethod for estimation. String encoding which moments are targeted.\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"For instance, running:","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"defines an EstimationSetup type with mode called Model1, modelname called benchmark and typemom set1.","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"Once EstimationSetup has been defined, ","category":"page"},{"location":"fragments/estimation/#MomentMatching.AuxiliaryParameters","page":"Estimation","title":"MomentMatching.AuxiliaryParameters","text":"abstract type AuxiliaryParameters\n\nDescription\n\nSupplies non-estimated auxuliary parameters, which are needed to compute model moments for any guess of the estimated parameters. Assumed to be non-random and constant over the estimation procedure.\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/#MomentMatching.PredrawnShocks","page":"Estimation","title":"MomentMatching.PredrawnShocks","text":"abstract type PredrawnShocks\n\nDescription\n\nSupplies pre-drawn shocks, which are needed to compute model moments for any guess of the estimated parameters. Assumed to be random, but constant over the estimation procedure (so that the minimization procedure works well). They are however re-simulated when performing bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/#MomentMatching.PreallocatedContainers","page":"Estimation","title":"MomentMatching.PreallocatedContainers","text":"abstract type PreallocatedContainers\n\nDescription\n\nSupplies empty arrays for computations to calculate model moments as few memory allocations as possible.\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"%@docs %NumParMM %","category":"page"},{"location":"fragments/estimation/#MomentMatching.ParMM","page":"Estimation","title":"MomentMatching.ParMM","text":"struct ParMM{S<:AbstractFloat}\n\nDescription\n\nStructure to store matching moments estimation inputs.\n\nFields\n\nlb_global: Lower bound for parameters in global stage\nub_global: Upper bound for parameters in global stage\nlb_hard: Hard lower bound for parameters - being outside brings penalty in local stage\nub_hard: Hard upper bound for parameters - being outside brings penalty in local stage\nlabels: Labels of estimated parameters\nmomdat: Moments from the data to match\nmmomdat: Normalizing factor moments from the data to match\nW: Weighting matrix\nmdifrec: Predetermined quantity to re-center moment condition\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/#Numerical-routines","page":"Estimation","title":"Numerical routines","text":"","category":"section"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"The main function to run the estimation routine is: ","category":"page"},{"location":"fragments/estimation/#MomentMatching.estimation","page":"Estimation","title":"MomentMatching.estimation","text":"estimation(estset::EstimationSetup;<keyword arguments>)\n\nEstimate model parameters given instance of EstimationSetup.\n\nCan be customized if non-default estimation cases have to be performed. Accepts initial guess(es) when only local stage is performed.\n\nKeyword arguments\n\nnpmm::NumParMM=NumParMM(estset): numerical parameters for estimation.\ncs::ComputationSettings=ComputationSettings(): computational options.\naux::AuxiliaryParameters=AuxiliaryParameters(estset): any additional pre-determined (i.e., not to be estimated) model-specific parameters.\npresh::PredrawnShocks=PredrawnShocks(estset, aux): pre-generated random shocks.\nxlocstart=[[1.0]]::Vector{Vector{Float64}}: starting point for local optimization when only local stage is performed.\nsaving::Bool=true: whether to save the final estimation results.\nsaving_bestmodel::Bool=saving: whether to save the results for the best parameters vectors.\nnumber_bestmodel::Integer=1: for how many best parameter vectors to save results.\nfilename_suffix::String=\"\": suffix to use in output filenames.\nerrorcatching::Bool=false: if true the estimation routine does not stop if an error happens when computing moments for a given parameter vector guess.\nvararg...: additional arguments passed.\n\n\n\n\n\n","category":"function"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"In addition to the model setup elements described above, the user can also define her preferred computational settings:","category":"page"},{"location":"fragments/estimation/#MomentMatching.ComputationSettings","page":"Estimation","title":"MomentMatching.ComputationSettings","text":"struct ComputationSettings{T<:Integer}\n\nDescription\n\nComputational settings for performing parallel computing either locally or on a cluster.\n\nFields\n\nlocation: Where computation is performed. 'local' and 'slurm' are supported presently Default: local\nnum_procs: Number of processes used by estimation and bootstrapping routines. Giving 1 avoids adding any new process. On Slurm cluster this has to be equal to :nodes * :ntaskspernode Default: 1\nnum_tasks: Number of tasks spawn per process in estimation and bootstrapping routines. Giving somewhat more than the number of actual threads is probably a good idea to avoid idleness. Setting it equal to one implies that only one thread per process will be used by functions in this package (even if more are present). Note that in this case multithreading within the internal function is possible as long that is written in a data-race free way. Default: Threads.nthreads() * 2\nnum_threads: Number of threads to be used when starting each new process. Relevant only with multiprocessing. On Slurm cluster this has to be equal to :cpuspertask Default: Int(floor(Threads.nthreads() / num_procs))\nmaxmem: Trigger intensive garbage collection at this memory usage Default: -1\nclustermanager_settings: Other settings Default: Dict(:x => \"\")\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"Furthermore, the user can decide:","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"whether to save the final estimation results through saving;\nwhether to save the evaluated moments for the best (i.e., those returning the lowest objective function values) number_bestmodel points through saving_bestmodel;\nwhether to add a specific suffix to saved files via filename_suffix;\nwhether to proceed with the estimation routine until the end if evaluation of the objective function at a specific candidate point returns an error errorcatching.","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"Additional model-specific arguments needed for model initialization can be passed through via vararg....","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"Results of the estimation routine are stored in a dedicated structure:","category":"page"},{"location":"fragments/estimation/#MomentMatching.EstimationResult","page":"Estimation","title":"MomentMatching.EstimationResult","text":"struct EstimationResult{S<:AbstractFloat, T<:Integer, U<:AuxiliaryParameters, V<:PredrawnShocks}\n\nDescription\n\nStructure to store output of matching moments estimation procedure.\n\nFields\n\nnpmm: Numerical parameters\naux: Auxiliary inputs\npresh: Predrawn shocks\nxlocstart: Starting parameters - relevant when only local stage is performed\npmm: Moment estimation inputs\nfglo: Objective function value in global stage, sorted in increasing order\nxglo: Parameter combinations checked in global stage, sorted according to objective function value\nmomglo: Moments from model, global stage\nfloc: Objective function value in local stage, sorted in increasing order\nxloc: Parameter combinations checked in local stage, sorted according to objective function value\nmomloc: Moments from model, local stage\nconv: Logical, if true convergence criterion at minimum is satisfied in the local stage\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/#Global-stage","page":"Estimation","title":"Global stage","text":"","category":"section"},{"location":"fragments/estimation/#Local-stage","page":"Estimation","title":"Local stage","text":"","category":"section"},{"location":"fragments/estimation/#Comparison-with-other-algorithms","page":"Estimation","title":"Comparison with other algorithms","text":"","category":"section"},{"location":"fragments/estimation/#Multithreading-and-multiprocessing","page":"Estimation","title":"Multithreading and multiprocessing","text":"","category":"section"},{"location":"fragments/estimation/#Locally","page":"Estimation","title":"Locally","text":"","category":"section"},{"location":"fragments/estimation/#Cluster","page":"Estimation","title":"Cluster","text":"","category":"section"},{"location":"fragments/estimation/#Two-step-estimation","page":"Estimation","title":"Two-step estimation","text":"","category":"section"},{"location":"fragments/gmm/#Relation-with-GMM","page":"-","title":"Relation with GMM","text":"","category":"section"},{"location":"fragments/gmm/","page":"-","title":"-","text":"In the above example we have explained how the procedure works with SMM, but extending usage of our package routines to GMM is straightforward. With GMM usually one has a set of moment conditions that should hold with equality and rather than simulating data from a model, actual data are used to compute such conditions over the points in the parameter space. ","category":"page"},{"location":"fragments/gmm/","page":"-","title":"-","text":"The user, therefore, in this case just needs to write their own code to compute such conditions and check how far away from zero they are. In other words, zero is the data moment to be used when computing the difference between model and data moments. ","category":"page"},{"location":"fragments/gmm/","page":"-","title":"-","text":"Note that since the default version of mdiff scales by the average of a specific data moment (if one targets just a moment the mean is clearly the moment itself), if such value is zero, the user also needs to write a mode-specific mdiff function.","category":"page"},{"location":"fragments/output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"fragments/output/","page":"Output","title":"Output","text":"Here describe the routines already provided to produce some graphs and tables with estimation results.","category":"page"},{"location":"fragments/output/#Figures","page":"Output","title":"Figures","text":"","category":"section"},{"location":"fragments/output/#Tables","page":"Output","title":"Tables","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"References are ruined on purpose, fix when they point somewhere","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Description. This package allows performing Method of Moments estimation (Generalized and Simulated).   It comprises three files which are not model-specific and are used in all applications and model-specific files. See below for more details.","category":"page"},{"location":"fragments/README/#Routine-files","page":"-","title":"Routine files","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"There are three files which are not model-specific and which are used in all applications:","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"SMMGMMestimation: contains structures and functions to perform the estimation;\nSMMGMMinference: contains functions to perform inference and diagnostics;\nSMMGMMoutput: contains structures and functions to produce tables and figures to display the estimation results.","category":"page"},{"location":"fragments/README/#1.-SMM*GMM*estimation","page":"-","title":"1. SMMGMMestimation","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"This is the core file performing the estimation routine. To describe the procedure let's introduce some useful notation:","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"x\n: array of data; \ntheta\n: array containing K parameters to be estimated;\ng(x theta)\n: array of M moment conditions, function of data and parameters, in the form g(x theta)=0;\nW\n: weighting matrix for the moment conditions with dimension M times M; \ng^primeWg\n: objective function to be minimized;\nS=mathbbEg(x theta)g(x theta)^prime\n: covariance matrix of the moments;\nG\n: matrix with the derivatives of the moment conditions with respect to theta with dimension M times K;\nHat over quantity: identifies estimators.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Note: identification requires M geq K.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"The estimation algorithm in the function [estimation] includes a global and a local stage in its most general form. Nevertheless, the code is flexible enough to allow performing only one of the two stages at a time. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Global stage. In the global stage (see [matchmom]) a Sobol sequence is generated on the parameter space defined by theta. The objective function is evaluated at each combination of parameters in the sequence. If only the global stage is performed, the best (in terms of lowest value of the objective function) combination of parameters is returned as the minimizer. Else, the best points (the number can be specified by the user) are used as starting guesses for the local stage. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Note: it is important that the number of global points evaluated is large, so that all the areas of the parameter space are searched well enough. This is especially true if the objective function is not well-behaved.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Local stage. The most promising candidates found in the global stage are then used as starting points for a local stage (see [opt_loc!]), in which the Nelder-Mead algorithm is used to find the minimum of the objective function. If only the local stage is performed, the initial guess can be supplied by the user. The global minimizer is then the best point among the values returned at the end of the local minimization routine at each tried starting guess.     ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"The file also contains a function [two_stage_estimation] to perform two-step GMM estimation. In the first step estimation is performed with a default weighting matrix. Parametric bootstrap (described in the next section) then allows to get the updated efficient weighting matrix (under the assumption that the model and estimated parameters are correct). The latter is then used as weighting matrix for estimation in the second step.","category":"page"},{"location":"fragments/README/#2.-SMM*GMM*inference","page":"-","title":"2. SMMGMMinference","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"This file contains functions to perform diagnostics and inference on the estimation results. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Diagnostics. In order to check that a minimum is achieved, the function [marginal_fobj] evaluates the objective function at points around the estimated parameter hattheta in one dimension at a time (see below for functions to plot this check) and saves the results in an array.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Parametric bootstrap. In order to gauge how precisely the targeted moments are estimated in the original data, a function param_bootstrap to perform parametric bootstrap is provided. Specifically, assuming model and estimated parameters are correct, alternative samples are simulated - with the same size as the original sample data sample - and, for each sample, an alternative vector of moments to match is computed. Then, for every alternative moment vector, the estimation procedure (local stage) is repeated. The resulting distribution of estimated parameters can be used to obtain the bootstrap confidence intervals. To check that the chosen seed does not influence the results (in which case it is recommended to restart the whole estimation with bigger simulation sizes), this procedure can optionally be repeated with several seeds.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Standard errors. The asymptotic variance [sandwich_matrix] of the parameter estimates has the usual sandwich form: (G^prime W G)^-1 G^prime W S W G(G^prime W G)^-1. hatG can is computed numerically at the estimated parameter value hattheta with the function [Qmatrix]. W is the weighting matrix used in estimation. Under the assumptions of the parametric bootstrap, there are two sources of variation in the parameter estimates: variation in the simulated sample for a given seed and across seeds. The parametric bootstrap procedure just outlined returns a distribution of the parameter estimates that considers exactly these two factors. Thus, the covariance matrix of the simulated moments is a consistent estimator for S and, after having been computed by the function [Omega_boots], it is used as hatS. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Note: If the model is just identified or if hatW is a consistent estimator of S^-1 then the variance simplifies to (G^prime S^-1 G)^-1. The latter happens, for instance, when hatW is the efficient weighting matrix obtained in the two-stage estimation procedure or, in the parametric bootstrap case just described when hatW is set to the inverse of the consistent estimator of S.  ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"J-test. A function [Jtest] to test over-identifying restriction is provided. The J-statistic is defined as nhatg^primehatWhatg where hatW is a consistent estimator of S^-1, hatg a consistent estimator of the moment conditions and n is the sample size. Under the null J rightarrow_d chi^2_M-K.  ","category":"page"},{"location":"fragments/README/#3.-SMM*GMM*output","page":"-","title":"3. SMMGMMoutput","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"This file contains functions to organize the estimation results and to perform some sanity checks on them. More specifically, the following figures and tables can be generated: ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"[fsanity]: figure plotting the estimated parameters in every trial of the global or local stage in increasing order with respect to the objective function value obtained. If the found optimum is stable, then the estimated parameter values should not vary much, especially for the trials that achieved objective function values close to the minimum.\n[fmarg]: figure plotting the how the objective function varies when marginally moving the estimated parameter in one dimension at a time. If the optimum is a minimum, then the graphs should show that the objective function is minimized at that point.\n[fbootstrap]: figure showing the histogram of parameter estimates obtained in each bootstrap iteration. \n[plotmoms]: figure comparing the moments in the data and in the model (at the estimated parameter values). \n[tableest]: table with parameter estimates, optionally including bootstrap SE.\n[tablemoms]: table comparing the moments in the data and in the model (at the estimated parameter values), optionally including bootstrap SE.","category":"page"},{"location":"fragments/README/#Model-specific-files","page":"-","title":"Model-specific files","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"This section describes the general format for model-specific files so that they can be used by the files performing the estimation routine. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"In general, the framework is flexible to accomodate any user-defined model. However, the following model-specific files should be included (as they are called in the general estimation routine):","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"[EstimationMode]: type for model to be estimated.\n[InnerAuxStructure]: type for the auxiliary structures to be initialized.\n[defaultInnerAuxStructure]: sets up default auxiliary object for computing model moments.\n[default_weight_matrix]: sets up default weighting matrix to compute the objective function.\n[datamoments]: computes moments from the data.\n[parambounds]: return parameter labels and ranges.\n[obj_mom]: computes moments in model under a given parameter guess.\n[mdiff]: computes deviation of model moments from data moments.\n[momentnames]: returns the full names of the moments, used for organising results.\n[mean_moments]: computes mean of moments, used for bootstrapping.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"In addition, the following can also be model-specific:","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"[indexvector]: if the default of having all model parameters estimated should be changed.\n[ftypemom]: if not having model-specific default moments to be estimated should be changed.\n[plotmoms]: if the default of having an empty graph to compare moments in the model and data should be changed.","category":"page"},{"location":"examples/#Example:-Estimating-an-AR(1)-process-with-noise","page":"Example","title":"Example: Estimating an AR(1) process with noise","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"Consider a stochastic process that is a sum of an AR(1) process and a white noise as follows:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"beginalign*\ny_it = z_it + nu_it\nz_it = rho cdot z_it-1 + varepsilon_it\nendalign*","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"where","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":" varepsilon_it sim mathcalN(0sigma_varepsilon^2) qquad  nu_it sim mathcalN(0sigma_nu^2)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"are i.i.d. shocks. The aim is to estimate parameters (rho sigma_varepsilon sigma_nu) based on a set of moments textVar(y_t) textCov(y_t y_t-1) textCov(y_t y_t-2) computed from an observed sample of y_its.","category":"page"},{"location":"examples/#Setting-up-the-problem","page":"Example","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"Being about to run a structural estimation exercise, one usually already has a piece of code that given","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"a guess for the estimated parameters;\n(possibly) a set of other parameters that are treated fixed;\n(possibly) a draw of random shocks;\n(possibly) a set of empty arrays (to avoid allocation while evaluating the function)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"can compute a set of counterfactual moments, which can then be compared to its empirical counterpart.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"To utilize this package one has to wrap this objective function and its inputs into functions and abstract types defined within the package. This is shown below.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"First, one needs to define an estimation mode:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using MomentMatching # hide\nstruct AR1Estimation <: EstimationMode \n    \"mode-dependent prefix of filenames used for saving estimation results\"\n    filename::String\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"During the estimation, one needs to evaluate the objective function for each parameter guess. Passing invariant parameters to the objective function is possible via defining an auxiliary structure which has to be a subtype of AuxiliaryParameters. One also needs to write a corresponding function to generate a default auxiliary structure as shown below. In this case, we pass the dimensions of the simulated sample.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"struct AR1AuxPar{T<:Integer} <: AuxiliaryParameters\n    \"sample size of simulation\"\n    Nsim::T\n    \"number of time periods to simulate\"\n    Tsim::T\n    \"number of periods to discard for moment evaluation \"\n    Tdis::T\nend\n\nAuxiliaryParameters(mode::AR1Estimation, modelname::String) = AR1AuxPar(10000, 200, 100)\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"It is crucial that the same set of shocks are used during the parameter estimation, as otherwise convergence cannot be achieved in the local minimization phase (the sensitivity of results to different draws of shocks can be checked via bootstrapping, as explained later in the Inference section). This is again done by defining an appropriate subtype of an existing abstract type and a function generating a default container of shocks. In this case, one needs to draw a normal shock for varepsilon and nu for each t and n.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"struct AR1PreShocks{S<:AbstractFloat} <: PredrawnShocks\n    \"preallocated array for persistent shocks\"\n    ϵs::Array{S,2}\n    \"preallocated array for transitory shocks\"\n    νs::Array{S,2}\nend\n\nfunction PredrawnShocks(mode::AR1Estimation, modelname::String, typemom::String,aux::AuxiliaryParameters)\n    return AR1PreShocks(randn(aux.Nsim, aux.Tsim),\n        randn(aux.Nsim, aux.Tsim))\nend\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"In order to compute the necessary moments of large samples, one often needs to populate large arrays with realized values(in our case, of y_its). Creating separate containers for each guess for the parameter vector would be very costly, so instead this is done once before starting the estimation, and the data contained within will be repeatedly overwritten ","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nWhen performing an estimation via parallel computing, these containers are internally generated separately for each thread, and hence data race is automatically avoided.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"In this example, we will compute cross-sectional moments in each time period and take their time-average in the final step. Therefore, we need to keep track of z and y (together its first and second lags) and the already computed moments. Defining the structure of preallocated data follows a similar logic as the previous steps.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"struct AR1PrealCont{S<:AbstractFloat} <: PreallocatedContainers\n    z::Vector{S}\n    y::Vector{S}\n    ylag1::Vector{S}\n    ylag2::Vector{S}\n    mat::Array{S,2}\nend\n\nfunction PreallocatedContainers(mode::AR1Estimation, modelname::String, typemom::String,\n aux::AuxiliaryParameters)\n\n    z = Vector{Float64}(undef, aux.Nsim)\n    y = Vector{Float64}(undef, aux.Nsim)\n    ylag1 = Vector{Float64}(undef, aux.Nsim)\n    ylag2 = Vector{Float64}(undef, aux.Nsim)\n\n    mat = Array{Float64}(undef, 3, aux.Tsim) # one row for each moment\n\n    return AR1PrealCont(z, y, ylag1, ylag2, mat)\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Now we are in the position of constructing the objective function. This is done via writing a method for MomentMatching.obj_mom!, specializing it on the subtype AR1Estimation created before.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using Statistics\nfunction MomentMatching.obj_mom!(mom::AbstractVector, momnorm::AbstractVector,\n mode::AR1Estimation, x::Array{Float64,1}, modelname::String, typemom::String,\n  aux::AuxiliaryParameters, presh::PredrawnShocks, preal::PreallocatedContainers;\n   saving_model::Bool=false, filename::String=\"\")\n    (ρ, σϵ, σν) = x\n\n    for n in 1:aux.Nsim\n        preal.z[n] = 0.0\n    end\n    for t in 1:aux.Tsim\n        for n in 1:aux.Nsim\n            preal.z[n] = ρ * preal.z[n] + σϵ * presh.ϵs[n, t]\n            preal.y[n] = preal.z[n] + σν * presh.νs[n, t]\n        end\n        if t > 2\n            preal.mat[3, t] = cov(preal.y, preal.ylag2)\n            copy!(preal.ylag2, preal.ylag1)\n        end\n        if t > 1\n            preal.mat[2, t] = cov(preal.y, preal.ylag1)\n            copy!(preal.ylag1, preal.y)\n        end\n        preal.mat[1, t] = var(preal.y)\n        copy!(preal.ylag1, preal.y)\n    end\n\n    mom[1] = mean(@view preal.mat[1, aux.Tdis:end])\n    momnorm[1] = mom[1]\n\n    mom[2] = mean(@view preal.mat[2, aux.Tdis:end])\n    momnorm[2] = mom[2]\n\n    mom[3] = mean(@view preal.mat[3, aux.Tdis:end])\n    momnorm[3] = mom[3]\n\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"We give the names and ranges of the targeted parameters by writing a method of parambounds. During the global phase of the estimation, the region within 'global' bounds is searched. Violating 'hard' bounds during the local phase induces a penalty to redirect the algorithm towards the allowed range.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"function MomentMatching.parambounds(mode::AR1Estimation)\n    full_labels    = [ \"ρ\",  \"σϵ\",  \"σν\"]\n    full_lb_hard   = [ 0.0,   0.0,  0.0 ]\n    full_lb_global = [ 0.0,   0.0,  0.0 ]\n    full_ub_global = [ 1.0,   1.0,  1.0 ]\n    full_ub_hard   = [ 1.0,   Inf,  Inf ]\n    return full_labels, full_lb_hard, full_lb_global, full_ub_global, full_ub_hard\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Next, we specify which moments are targeted during the estimation. In an actual application, this function would most likely read in values from a dataset, but here we just give three arbitrary numbers for each moments.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"function MomentMatching.datamoments(mode::AR1Estimation, typemom::String)\n    momtrue = [0.8, 0.45, 0.4] # made up numbers\n\n    mmomtrue = deepcopy(momtrue)\n\n    return hcat(momtrue, mmomtrue)\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Finally, we name the targeted moments. The momentnames function has to return a DataFrame with two columns, where one targeted moment corresponds to one row. If the two moments have coinciding values in the first column, the corresponding results will be visualized together, as shown in section Estimation.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using DataFrames\nfunction MomentMatching.momentnames(mode::AR1Estimation, typemom::String)\n    moments = fill(\"Cov(y_t,y_t-j)\", 3)\n    lags = string.(0:2)\n    return DataFrame(Moment=moments, Lags=lags)\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nBy default the deviation between data and model moments is obtained by rescaling the difference between the two with data means of each moment. For instance, if one targets the time-series of the cross-sectional skewness of the distribution of income growth, the differences in each year would be scaled by the time-series average of the cross-sectional skewness (clearly, if one targets just one moment the mean is the moment itself). The user can change this by writing a mode-specific mdiff function (see related code in estimation.jl).","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"To summarize, when applying this package for existing code, follow these steps:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Set up an EstimationMode structure.\nWrite EstimationMode-specific auxiliary structures AuxiliaryParameters (for any input that stays constant all over the estimation), PredrawnShocks (for simulation noise) and PreallocatedContainers (containers which can be overwritten over the estimation) whenever relevant. These will be inputs of the objective function.\nSet the bounds of the parameter space and the values of the moments to be matched by writing an EstimationMode-specific MomentMatching.parambounds and MomentMatching.datamoments functions. \nWrap the objective function within an appropriate method of MomentMatching.obj_mom!.","category":"page"},{"location":"examples/#Example.Estimation","page":"Example","title":"Estimation","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"After defining an estimation setup (see section Estimating alternative specifications for more details on why this structure is useful) and a structure supplying numerical settings, one can perform the estimation as follows. After checking 100 points in the global phase, a local minimization takes place using the Nelder-Mead algorithm, started from the 10 global points with the lowest objective function values. ","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nIn this example we use the default weighting matrix - which is the unitary matrix - but the user can change this by defining a a mode-specific default_weight_matrix function (see related code in estimation.jl) or by passing their preferred weighting matrix via the keyword argument Wmat to estimation.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using OptimizationOptimJL\nsetup = EstimationSetup(AR1Estimation(\"ar1estim\"), \"\", \"\")\n\nnpest = NumParMM(setup; Nglo=100, Nloc=10,\n local_opt_settings = (algorithm = NelderMead(), maxtime = 30.0))\n\nest = estimation(setup; npmm=npest, saving=false); \nnothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The estimated parameters can be displayed as follows:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"tableest(setup, est)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The match with targeted moments can either be displayed as a table","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"tablemoms(setup, est)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"or visualized on a figure:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using Plots\nfmoms(setup, est)\nsavefig(\"fmoms.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"As in this case 3 parameters were estimated based on 3 moments (and hence parameters are exactly identified), the resulting match is very close.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Results can be saved by setting saving equal to true. In this case filename specified in estimation mode will be used as suffix. The default saving path is \"./saved/estimation_results/\". ","category":"page"},{"location":"examples/#Diagnostics","page":"Example","title":"Diagnostics","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"When the objective function is highly non-linear, it is in general difficult to know if the obtained parameter estimate indeed corresponds to a global minimizer. One concern would be that the obtained local optimum is 'too local', i.e. its basin of attraction is too narrow. In this case the local optimum would be very sensitive to the respective initial point. To judge the accuracy of the estimated parameter vector, two heuristic methods are available in this package.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"First, it is possible to visualize how the objective function depends on varying the parameter estimates one-at-a-time (keeping the other parameters constant), around the best point.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"marg = marginal_fobj(setup, est, 17, fill(0.1, 3))\nfmarg(setup, est, marg)\nsavefig(\"fmarg.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Second, one can visualize how sensitive the corresponding parameter values are to the rank of the corresponding global or local point, with respect to their objective function values. This is informative on the sufficient number of global and local points.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Output from the global stage is available via the global keyword.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"fsanity(setup, est, glob = true)\nsavefig(\"fsanity_glo.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"By default, results from the local stage are shown.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"fsanity(setup, est)\nsavefig(\"fsanity_loc.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/#Example.Inference","page":"Example","title":"Inference","text":"","category":"section"},{"location":"examples/#Parametric-Bootstrap","page":"Example","title":"Parametric Bootstrap","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"Even if the model is correctly specified, there are two reasons why parameters are estimated with an error:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The targeted population moments are obtained from a finite sample.\nIf evaluating the objecting function involves uncertainty, the whole estimation procedure is conducted with one particular draw of shocks. This makes results potentially sensitive to this specific realization of shocks.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"One can gauge the joint effect of these forces on the precision of the estimates via parametric bootstrapping. ","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"First, using the obtained parameter estimates, N_sample independent samples are created to mimic the uncertainty in the data generating process. The targeted moments are then computed from each of these samples. Note that the size of the simulated samples have to coincide with the actual data sample which was used to compute the data moments.\nSecond, if computing the objective function involves random draws, N_seed number of different shocks are draws.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Then for each pair of alternative moments and seeds, the local stage of the estimation is repeated starting from the best local point of the original estimation. The distribution of the resulting N_sample cdot N_seed new estimates can then be used to generate confidence intervals.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Tdis = 20 # burn in\nTdata = 40 # true data length\nNdata = 500 # true sample size\nNsample = 15 # number of samples used for bootstrap\nNseed = 15 # number of shock simulations used for bootstrap\nauxmomsim = AR1AuxPar(Ndata, Tdata + Tdis, Tdis)\nboot = param_bootstrap_result(setup, est, auxmomsim, Nseed, Nsample, Ndata, saving=false);\n\nfbootstrap(setup, est, boot)\nsavefig(\"fbootstrap.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/#Example.Multi","page":"Example","title":"Multithreading and multiprocessing","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"The global and local phases of the estimation procedure require evaluating the objective function at many points of the parameter space. In our package this task can be parallelized with multithreading (Threads module, distributes across cores within a process), multiprocessing (Distributed module, distributes across different processes) and/or a combination of the two (distributes across different processes and then across the cores within a process) by appropriately setting the structure ComputationSettings. To apply some given computational settings, one just need to pass it to the estimation function with the keyword argument cs. We describe below how to do this locally on one's computer and on a cluster.","category":"page"},{"location":"examples/#Local-parallelization","page":"Example","title":"Local parallelization","text":"","category":"section"},{"location":"examples/#Multithreading","page":"Example","title":"Multithreading","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"In this case the only relevant field in ComputationSettings is num_tasks. If for example we run","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"cs_1 = ComputationSettings(num_tasks=4)\nest_1 = estimation(setup; npmm=npest, cs=cs_1, saving=false);","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"then in the global estimation phase, four tasks will be spawn, with each containing a quarter of all points where the objective function needs to be computed. These tasks are then queued at the available threads, the number of which depends on how Julia was started (as usual), in particular the option -t/--threads command line argument or  the JULIA_NUM_THREADS environment variable (see here). After the global phase is finished, the starting points for the local phase are also shared between 4 tasks.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nChoosing a higher number for num_tasks than JULIA_NUM_THREADS and thus overscheduling the threads might help prevent idleness. \nThe default value for num_tasks is Threads.nthreads()*2, implying that multithreading is active by default and that threads are overscheduled.\nForcing single-threading is possible via setting num_tasks to 1.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nWhen using multithreading, separate PreallocatedContainers are spawn for each task, and the containers of estimation outputs are accessed elementwise, hence data races are prevented as long as no other object is being overwritten in the objective function written by the user.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The code below performs the global stage locally (location=\"local\") in three ways:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Two processes (num_procs=2), each started with two threads (i.e., cores num_threads=2) and no multithreading (num_tasks=1).\nOne process (default) with all avaliable threads (default with one process) and multithreading (num_tasks defaults to Threads.nthreads()*2).\nTwo processes, each started with two threads and multithreading.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nMultiprocessing distributes the total number of points to be evaluated equally across the number of processes.\nThe default option for num_tasks tries to minimize idleness and implies that multithreading is active by default.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The difference between the first and the third case is that in the latter evaluation of points is distributed across the two threads while in the former two cores are used but evaluation of points is not parallelized across them.","category":"page"},{"location":"examples/#Multiprocessing","page":"Example","title":"Multiprocessing","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"Given that memory is not shared across the different processes, before running any code using multiprocessing we need to make sure that the required elements (functions, packages, structures, types...) are loaded in each of them. The function to do that is load_on_procs. Specifically, one writes a Julia script dedicated to loading all the required elements and calls it in load_on_procs which takes care of running it in every process. In our case such file is called minimalAR1.jl and it basically loads the functions, packages, structures, types, etc. that we have used so far in this example (if you want to have a look, the script is available in the test/examples folder of the GitHub repository of the package). Be sure to specify the path correctly when calling include.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"julia> using Distributed\njulia> function MomentMatching.load_on_procs(mode::AR1Estimation)\n    return @everywhere begin include(\"minimalAR1.jl\") end\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Besides telling Julia what to run on each process when starting them, we also need to specify","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"how many processes we want\nwith how many threads the new Julia instances should start","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"via the num_proc and num_threads fields of the ComputationalSettings structure. Note that when multiprocessing is active, num_tasks will set the number of tasks per process.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"For example,","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"ComputationSettings(num_procs=8, num_threads=1, num_tasks=1) starts 8 processes without any multithreading on each. At most 8 points can be evaluated at the same time.\nComputationSettings(num_procs=8, num_threads=4, num_tasks=8) starts 8 processes with 4 threads and 8 tasks on each. On each process, 4 tasks can immediately be scheduled to threads immediately, while 4 other ones will wait. At most 32 points can be evaluated at the same time.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nWhen via the estimation function both the global and local phases are performed in one go, the same specified computational settings are applied to both. It is also possible to run each phase separately with its own computational settings (see the section Only global or only local the description of how to run the two stages separately). ComputationSettings also works in the function performing bootstrapping.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"danger: Danger\nWhile the package is designed in a way to prevent data races in the estimation and bootstrapping routines, it is always the user's responsibility to check that this does not happen in their own model. In addition, it is best to avoid applying multithreading in one's model code within obj_mom! if multithreading is already active when looping over points in the parameter space.","category":"page"},{"location":"examples/#Parallelization-on-a-cluster","page":"Example","title":"Parallelization on a cluster","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"Currently, our package works only on clusters using Slurm Workload Manager. This is an example on how to set ComputationSettings for running the estimation on Slurm:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"cs = ComputationSettings(location = \"slurm\", \nnum_procs = 16,\nnum_tasks = 8,\nnum_threads = 8,\nmaxmem = 70, \nclustermanager_settings = Dict(:A => \"x\",\n :job_name => \"y\",\n :nodes => \"4\",\n :ntasks_per_node => \"4\",\n :cpus_per_task => \"8\",\n :exclusive => \"\",\n :mem => \"90GB\",\n :time => \"23:59:59\",\n :partition => \"z\"))","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"We have specified the following options:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"location = \"slurm\" the computation should be run on Slurm manager\nnum_procs = 16 the total number of processes to be started (16 in this case). On Slurm this has to be equal to :nodes * :ntasks_per_node\nnum_tasks = 8 the number of tasks per thread to be performed \nnum_threads = 8 number of threads to be started in each Julia process. On Slurm this has to be equal to :cpus_per_task (see below)\nmaxmem = 70 specifies the level in GB where aggressive garbage collection is triggered, should be less than :mem (see below) to avoid using more than the allocated resources\nclustermanager_settings is a flexible Dictionary which passes the relevant options to Slurm. In this case we have specified:\n:A the project account to be charged for the computational allocation requested\n:job_name the name of the job \n:nodes how many HPC nodes are to be used (4 in this case)\n:ntasks_per_node how many processes per node have to be started (4 in this case), must be less than the number of cores per node \n:cpus_per_task how many cores are to be used per process (8 in this case), must be less than number of cores on node\n:exclusive that the job allocation cannot share nodes with other running jobs\n:mem the total memory requested per node\n:time the total time requested\n:partition the name of the HPC partition to use\nSee the Slurm docs for more details and options.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Users can thus perform multiprocessing, multithreading and/or a combination of the two also on a cluster which uses Slurm by properly specifying these options. Including ComputationSettings defined in the way just explained in the estimation command will automatically ensure that the latter is run with Slurm.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nThe word task has different meanings in Slurm and in this package: in our package (in line with Julia terminology) it refers to the number of tasks for multithreading, while in Slurm it means the number of processes per node.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nApplying this package with different cluster managing systems than Slurm should be possible via a slight modification of the Distributed.addprocs(cs::ComputationSettings) function. Any related pull request is greatly appreciated!","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nHardware configuration and rules for Slurm options to be included might differ across HPCs. The user should make sure that the options conform with their specific case. \nIf on a cluster, it's important to remember to set up correctly the required environment by loading the packages and functions before running the estimation.\nIf one runs the code from an open Julia session in the HPC then the Slurm command called is srun. It should be possible to use also sbatch by writing a script that calls the code.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"tip: Tip\nThe best combination of options to choose in ComputationSettings (both when running jobs locally and on HPC) depends on the specific model and computer configuration used. For instance, while setting up multiple processes enhances parallelization, initializing them also requires time. We encourage users to experiment different combinations to figure out which one is the best for their setting.","category":"page"},{"location":"examples/#Other-useful-features","page":"Example","title":"Other useful features","text":"","category":"section"},{"location":"examples/#Example.Alternative","page":"Example","title":"Estimating alternative specifications","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"The package allows easy estimation of alternative model specifications or using a different set of moments. For instance, imagine that we want to estimate the original model without the noise, i.e., sigma_nu=0, by targeting only the variance and the first-order autocovariance. The first step is to define appropriately the structure EstimationSetup:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"setup_noise_off = EstimationSetup(AR1Estimation(\"ar1estim\"), \"noise_off\", \"onlytwo\");\nnothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The first element is EstimationMode (as we had before, and we keep it the same since we are considering a restricted version of the original model), the second element is a string specifying how we want to call this restricted specification (modelname), and the latter is a string specifying how to call the set of moments to target (typemom). Note that these two strings were defined as empty in the case presented before.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nThe modelname and typemom strings will be automatically included in the names of saved files.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Then, one specifies which parameters have to be estimated (relative to the order specified in parambounds) with the function indexvector:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"function MomentMatching.indexvector(mode::AR1Estimation, modelname::String)\n    indexvec = fill(true, length(parambounds(mode)[1]))\n    \n    if modelname == \"noise_off\" # we do not estimate the noise variance (which is the third element in parambounds)\n        indexvec[3] = false\n    end\n\n    return indexvec\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nIf indexvector is not specified by the user, the algorithm includes all the parameters in parambounds. ","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Similarly, the set of moments to be targeted can be specified by redefining MomentMatching.datamoments for different typemom:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"function MomentMatching.datamoments(mode::AR1Estimation, typemom::String)\n    momtrue = [0.8, 0.45, 0.4] # made up numbers\n\n    mmomtrue = deepcopy(momtrue)\n\n    if typemom == \"\"\n        return hcat(momtrue, mmomtrue)\n    elseif typemom == \"onlytwo\" # in this case only first two moments used\n        return hcat(momtrue[1:2], mmomtrue[1:2])\n    end\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"In this case we target only the first two moments. Finally, we redefine also the objective function:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"function MomentMatching.obj_mom!(mom::AbstractVector, momnorm::AbstractVector,\n mode::AR1Estimation, x::Array{Float64,1}, modelname::String, typemom::String,\n  aux::AuxiliaryParameters, presh::PredrawnShocks, preal::PreallocatedContainers;\n   saving_model::Bool=false, filename::String=\"\")\n    \n    if modelname == \"\"\n        (ρ, σϵ, σν) = x\n    elseif modelname == \"noise_off\" # we set the last parameter to zero\n        (ρ, σϵ, σν) = vcat(x, 0.0)\n    end\n\n    for n in 1:aux.Nsim\n        preal.z[n] = 0.0\n    end\n    for t in 1:aux.Tsim\n        for n in 1:aux.Nsim\n            preal.z[n] = ρ * preal.z[n] + σϵ * presh.ϵs[n, t]\n            preal.y[n] = preal.z[n] + σν * presh.νs[n, t]\n        end\n        if t > 2\n            preal.mat[3, t] = cov(preal.y, preal.ylag2)\n            copy!(preal.ylag2, preal.ylag1)\n        end\n        if t > 1\n            preal.mat[2, t] = cov(preal.y, preal.ylag1)\n            copy!(preal.ylag1, preal.y)\n        end\n        preal.mat[1, t] = var(preal.y)\n        copy!(preal.ylag1, preal.y)\n    end\n\n    mom[1] = mean(@view preal.mat[1, aux.Tdis:end])\n    momnorm[1] = mom[1]\n\n    mom[2] = mean(@view preal.mat[2, aux.Tdis:end])\n    momnorm[2] = mom[2]\n\n    if typemom == \"\" # this moment is needed only in the benchmark case\n        mom[3] = mean(@view preal.mat[3, aux.Tdis:end])\n        momnorm[3] = mom[3]\n    end\n\nend\n","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nBesides the number of estimated parameters, modelname could also influence in which way the moments determined by typemom are computed, making more general robustness checks also easy to implement.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"We also redefine the function to present the results: ","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"function MomentMatching.momentnames(mode::AR1Estimation, typemom::String)\n    moments = fill(\"Cov(y_t,y_t-j)\", 3)\n    lags = string.(0:2)\n    if typemom == \"\"\n        return DataFrame(Moment=moments, Lags=lags)\n    elseif typemom == \"onlytwo\"\n        return DataFrame(Moment=moments[1:2], Lags=lags[1:2])\n    end\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"note: Note\nIn a similar fashion, it is possible to make modelname- and typemom-specific also the auxiliary functions and the default matrix.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"We are now ready to run the estimation of the restricted model: ","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"est_noise_off = estimation(setup_noise_off; npmm=npest, saving=false);\ntableest(setup_noise_off, est_noise_off)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"tablemoms(setup_noise_off, est_noise_off)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Alternatively, one could also estimate the restricted model by targeting the original  three moments as follows. In this case the system is overidentified, and hence the moments cannot be matched exactly.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"setup_noise_off_threemoments = EstimationSetup(AR1Estimation(\"ar1estim\"), \"noise_off\", \"\");\nest_noise_off_threemoments = estimation(setup_noise_off_threemoments; npmm=npest, saving=false);\ntableest(setup_noise_off_threemoments, est_noise_off_threemoments)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"tablemoms(setup_noise_off_threemoments, est_noise_off_threemoments)","category":"page"},{"location":"examples/#Example.Onlyone","page":"Example","title":"Only global or only local","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"In the main example above both the global and local stages were performed in the same call. It is possible to perform only the global or only the local stage with the options onlyglo and onlyloc available in NumParMM: ","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"npest_glo = NumParMM(setup; Nglo=100, onlyglo=true)\nnpest_loc = NumParMM(setup; onlyloc=true,local_opt_settings = (algorithm = NelderMead(), maxtime = 30.0))\n\nest_glo = estimation(setup; npmm=npest_glo, saving=false)\n# use the best 10 global as starting points\nest_loc = estimation(setup; npmm=npest_loc, xlocstart = est_glo.xglo[1:10], saving=false) \nnothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Note that in this example results might differ slightly from the estimation above because new shocks have been drawn (and because of the low maximum time - for exemplificatory purposes - specified for the solver in the local stage). It is possible to draw the shocks once and then pass them across different calls of estimation with the presh option.","category":"page"},{"location":"examples/#Merging-results","page":"Example","title":"Merging results","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"For very long estimation exercises it can be useful to split the evaluation of global and/or local points across different calls of estimation and save the results after each call (so that if something goes wrong one does not need to recompute everything from scratch). For instance, to evaluate 10000 global points one can call estimation four times, each time evaluating 2500 points and then saving the results in one merged file (choosing which global points to evaluate in a given parameter space can be achieved through the option sobolinds in estimation). The function to achieve this is mergeglo. Below an example with 100 global points evaluated with two calls:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"npest_glo_batch1 = NumParMM(setup; sobolinds=1:50, onlyglo=true)\nnpest_glo_batch2 = NumParMM(setup; sobolinds=51:100, onlyglo=true)\n\nest_batch1 = estimation(setup; npmm=npest_glo_batch1, saving=false) \nest_batch2 = estimation(setup; npmm=npest_glo_batch2, saving=false)\n\nestmerged = mergeglo(setup, [est_batch1, est_batch2]; saving=false)\nnothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"In this case, the estimation results to be merged were already in memory when merging, but one can of course load any already saved estimation result (again, note that results might be different from previous estimations for the same reasons described before).","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"A similar procedure can be applied for the local stage with the function mergeloc (in this case the user needs to specify the starting points to be evaluated with the option xlocstart in estimation). Finally, the function mergegloloc allows to merge together separate global and local results.","category":"page"},{"location":"#MomentMatching.jl","page":"Home","title":"MomentMatching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a unified framework to perform Method of Moments (Generalized and Simulated) parameter estimation for economic models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generalized Method of Moments (GMM) estimation[1] consists in finding the vector of parameters theta that solves the following system of equations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbbEleftgleft(thetaright)right=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"where g is a vector of functions representing moment conditions derived from a model depending on the vector of parameters to be estimated theta. When moment conditions are computed via simulation, the above procedure is called Simulated Method of Moments (SMM) estimation.[2]","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the system is over-identified (g has higher dimensionality than theta), solving such an equation exactly is in general not possible. Instead, the goal becomes finding the vector of parameters theta that minimizes the following objective function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g(theta)^prime W g(theta)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where W is a weighting matrix.[3] ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims at providing a general toolbox for such estimation exercises, irrespective of what model one wants to estimate. Ready-to-use tools are provided to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"estimate theta via a combination of global search and a local optimization routine;\nperform diagnostic checks on the results; \ndo statistical inference and \nproduce tables and figures displaying the estimation results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package was built having in mind three key features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ease of use: The user just needs to write a wrapper around her code conformable with the estimation routines and set the algorithm options before running the main estimation function. This is an easy task even if the model code was not written specifically to be compatible with this package. \nFlexibility: Routines can be used for the estimation of any model. Estimation of robustness checks and alternative model specifications is convenient.\nParallelization: Multithreading and multiprocessing (also combined) are supported, both locally and on a cluster.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MomentMatching\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package use the command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MomentMatching","category":"page"},{"location":"#Authors-and-citing","page":"Home","title":"Authors and citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gualtiero Azzalini (Stockholm School of Economics) \nZoltán Rácz (Stockholm School of Economics)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please consider citing the package if you use MomentMatching in your research:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{MomentMatching.jl,\n  title = {{MomentMatching.jl}: Parameter Estimation of Economic Models via Moment Matching Methods in Julia},\n  author = {Azzalini, Gualtiero and Rácz, Zoltán},\n  year = {2024},\n  howpublished = {\\url{https://github.com/ZoltanRacz/MomentMatching.jl}}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Hansen, L. P. (1982). Large Sample Properties of Generalized Method of Moments Estimators. Econometrica, 50(4), 1029–1054. https://doi.org/10.2307/1912775.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: McFadden, D. (1989). A Method of Simulated Moments for Estimation of Discrete Response Models Without Numerical Integration. Econometrica, 57(5), 995–1026. https://doi.org/10.2307/1913621.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Clearly, this procedure can also be used in the just-identified case and it should deliver the same result as the one obtained when using routines to solve system of equations.","category":"page"},{"location":"fragments/inference/#Inference-and-Diagnostics","page":"Inference and Diagnostics","title":"Inference and Diagnostics","text":"","category":"section"},{"location":"fragments/inference/#Asymptotics","page":"Inference and Diagnostics","title":"Asymptotics","text":"","category":"section"},{"location":"fragments/inference/#Bootstrap","page":"Inference and Diagnostics","title":"Bootstrap","text":"","category":"section"},{"location":"fragments/inference/#Parametric","page":"Inference and Diagnostics","title":"Parametric","text":"","category":"section"},{"location":"fragments/inference/#Non-parametric","page":"Inference and Diagnostics","title":"Non-parametric","text":"","category":"section"},{"location":"fragments/inference/#Testing-over-identifying-restrictions","page":"Inference and Diagnostics","title":"Testing over-identifying restrictions","text":"","category":"section"},{"location":"fragments/inference/#Diagnostics","page":"Inference and Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"fragments/index_longer/#MomentMatching.jl","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"","category":"section"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Generalized Method of Moments (GMM) estimation[1] consists in finding the vector of parameters theta that solves the following system of equations:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"mathbbEleftgleft(thetaright)right=0","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"where g is a vector of functions representing moment conditions derived from a model depending on the vector of parameters to be estimated theta. When moment conditions are computed via simulation, the above procedure is called Simulated Method of Moments (SMM) estimation.[2]","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Letting k be the dimensionality of theta and m that of g, if:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"mk, then the system does not have a solution;\nm=k, then the system is just-identified and there is a unique solution;\nmk, then the system is over-identified and more than one solution is possible.","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"In the just-identified case, common procedures to solve system of equations can be used. However, when the system is over-identified, this approach is not possible. Instead, the goal becomes finding the vector of parameters theta that minimizes the following objective function:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"g(theta)^prime W g(theta)","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"where W is a weighting matrix.[3] ","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"This package provides a series of numerical routines to perform Method of Moments estimation (Generalized and Simulated), i.e., find an estimate of the vector theta (see section Estimation). It also contains ready-to-use tools (i) to check the quality of the estimation results and to do statistical inference (see section Inference and Diagnostics) and (ii) to produce tables and figures displaying estimation results (see section Output).","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"The package was built having in mind three key features:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Flexibility: routines can be used for estimation of any model;\nParallelization: multithreading and multiprocessing (also combined) are supported, both locally and on a cluster;\nEase of use: the user just needs to write her model in a way conformable with the estimation routines and set the algorithm options before running the main estimation function.","category":"page"},{"location":"fragments/index_longer/#Installation","page":"MomentMatching.jl","title":"Installation","text":"","category":"section"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"To install the package run:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"using Pkg\nPkg.add(\"MomentMatching\")","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"To load the package use the command:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"using MomentMatching","category":"page"},{"location":"fragments/index_longer/#Authors-and-citing","page":"MomentMatching.jl","title":"Authors and citing","text":"","category":"section"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Gualtiero Azzalini (Stockholm School of Economics) \nZoltán Rácz (Stockholm School of Economics)","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Please consider citing the package if you use MomentMatching in your research:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"@misc{MomentMatching.jl,\n  title = {{MomentMatching.jl}: Parameter Estimation of Economic Models via Moment Matching Methods in Julia},\n  author = {Azzalini, Gualtiero and Rácz, Zoltán},\n  year = {2024},\n  howpublished = {\\url{https://github.com/ZoltanRacz/MomentMatching.jl}}\n}","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"[1]: Hansen, L. P. (1982). Large Sample Properties of Generalized Method of Moments Estimators. Econometrica, 50(4), 1029–1054. https://doi.org/10.2307/1912775.","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"[2]: McFadden, D. (1989). A Method of Simulated Moments for Estimation of Discrete Response Models Without Numerical Integration. Econometrica, 57(5), 995–1026. https://doi.org/10.2307/1913621.","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"[3]: Clearly, this procedure can also be used in the just-identified case and it should deliver the same result as the one obtained when using routines to solve system of equations.","category":"page"}]
}
