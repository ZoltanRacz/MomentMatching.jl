var documenterSearchIndex = {"docs":
[{"location":"fragments/estimation/#Estimation","page":"Estimation","title":"Estimation","text":"","category":"section"},{"location":"fragments/estimation/#Model-setup","page":"Estimation","title":"Model setup","text":"","category":"section"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"The first step of the estimation routine is for the user to define her own model type through:","category":"page"},{"location":"fragments/estimation/#MomentMatching.EstimationSetup","page":"Estimation","title":"MomentMatching.EstimationSetup","text":"struct EstimationSetup{U<:EstimationMode}\n\nDescription\n\nStructure to store setup of matching moments estimation procedure.\n\nFields\n\nmode: Estimation mode.\nmodelname: Submethod for estimation. String encoding which parameters and how are estimated.\ntypemom: Submethod for estimation. String encoding which moments are targeted.\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"For instance, running:","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"defines an EstimationSetup type with mode called Model1, modelname called benchmark and typemom set1.","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"Once EstimationSetup has been defined, ","category":"page"},{"location":"fragments/estimation/#MomentMatching.AuxiliaryParameters","page":"Estimation","title":"MomentMatching.AuxiliaryParameters","text":"abstract type AuxiliaryParameters\n\nDescription\n\nSupplies non-estimated auxuliary parameters, which are needed to compute model moments for any guess of the estimated parameters. Assumed to be non-random and constant over the estimation procedure.\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/#MomentMatching.PredrawnShocks","page":"Estimation","title":"MomentMatching.PredrawnShocks","text":"abstract type PredrawnShocks\n\nDescription\n\nSupplies pre-drawn shocks, which are needed to compute model moments for any guess of the estimated parameters. Assumed to be random, but constant over the estimation procedure (so that the minimization procedure works well). They are however re-simulated when performing bootstrap.\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/#MomentMatching.PreallocatedContainers","page":"Estimation","title":"MomentMatching.PreallocatedContainers","text":"abstract type PreallocatedContainers\n\nDescription\n\nSupplies empty arrays for computations to calculate model moments as few memory allocations as possible.\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"%@docs %NumParMM %","category":"page"},{"location":"fragments/estimation/#MomentMatching.ParMM","page":"Estimation","title":"MomentMatching.ParMM","text":"struct ParMM{S<:AbstractFloat}\n\nDescription\n\nStructure to store matching moments estimation inputs.\n\nFields\n\nlb_global: Lower bound for parameters in global stage\nub_global: Upper bound for parameters in global stage\nlb_hard: Hard lower bound for parameters - being outside brings penalty in local stage\nub_hard: Hard upper bound for parameters - being outside brings penalty in local stage\nlabels: Labels of estimated parameters\nmomdat: Moments from the data to match\nmmomdat: Normalizing factor moments from the data to match\nW: Weighting matrix\nmdifrec: Predetermined quantity to re-center moment condition\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/#Numerical-routines","page":"Estimation","title":"Numerical routines","text":"","category":"section"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"The main function to run the estimation routine is: ","category":"page"},{"location":"fragments/estimation/#MomentMatching.estimation","page":"Estimation","title":"MomentMatching.estimation","text":"estimation(estset::EstimationSetup;<keyword arguments>)\n\nEstimate model parameters given instance of EstimationSetup.\n\nCan be customized if non-default estimation cases have to be performed. Accepts initial guess(es) when only local stage is performed.\n\nKeyword arguments\n\nnpmm::NumParMM=NumParMM(estset): numerical parameters for estimation.\ncs::ComputationSettings=ComputationSettings(): computational options.\naux::AuxiliaryParameters=AuxiliaryParameters(estset): any additional pre-determined (i.e., not to be estimated) model-specific parameters.\npresh::PredrawnShocks=PredrawnShocks(estset, aux): pre-generated random shocks.\nxlocstart=[[1.0]]::Vector{Vector{Float64}}: starting point for local optimization when only local stage is performed.\nsaving::Bool=true: whether to save the final estimation results.\nsaving_bestmodel::Bool=saving: whether to save the results for the best parameters vectors.\nnumber_bestmodel::Integer=1: for how many best parameter vectors to save results.\nfilename_suffix::String=\"\": suffix to use in output filenames.\nerrorcatching::Bool=false: if true the estimation routine does not stop if an error happens when computing moments for a given parameter vector guess.\nvararg...: additional arguments passed.\n\n\n\n\n\n","category":"function"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"In addition to the model setup elements described above, the user can also define her preferred computational settings:","category":"page"},{"location":"fragments/estimation/#MomentMatching.ComputationSettings","page":"Estimation","title":"MomentMatching.ComputationSettings","text":"struct ComputationSettings{T<:Integer}\n\nDescription\n\nComputational settings\n\nFields\n\nlocation: where computation is performed. 'local' and 'slurm' are supported presently Default: local\nnum_procs: Number of processes. Giving 1 avoids multiprocessing (since adding only one worker would have negative effect on performance, as master is not used in the loop). On a cluster give number of nodes (Should double check this). Default: 1\nnum_tasks: Number of tasks per process. Giving somewhat more than the number of actual ( virtual or physical ?? ) threads is probably a good idea.   Default: Threads.nthreads() * 2\nnum_threads: Number of threads that each processes are started with. Default: num_tasks\nmaxmem: Trigger intensive garbage collection at this memory usage Default: -1\nclustermanager_settings: Other settings Default: Dict(:x => \"\")\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"Furthermore, the user can decide:","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"whether to save the final estimation results through saving;\nwhether to save the evaluated moments for the best (i.e., those returning the lowest objective function values) number_bestmodel points through saving_bestmodel;\nwhether to add a specific suffix to saved files via filename_suffix;\nwhether to proceed with the estimation routine until the end if evaluation of the objective function at a specific candidate point returns an error errorcatching.","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"Additional model-specific arguments needed for model initialization can be passed through via vararg....","category":"page"},{"location":"fragments/estimation/","page":"Estimation","title":"Estimation","text":"Results of the estimation routine are stored in a dedicated structure:","category":"page"},{"location":"fragments/estimation/#MomentMatching.EstimationResult","page":"Estimation","title":"MomentMatching.EstimationResult","text":"struct EstimationResult{S<:AbstractFloat, T<:Integer, U<:AuxiliaryParameters, V<:PredrawnShocks}\n\nDescription\n\nStructure to store output of matching moments estimation procedure.\n\nFields\n\nnpmm: Numerical parameters\naux: Auxiliary inputs\npresh: Predrawn shocks\nxlocstart: Starting parameters - relevant when only local stage is performed\npmm: Moment estimation inputs\nfglo: Objective function value in global stage, sorted in increasing order\nxglo: Parameter combinations checked in global stage, sorted according to objective function value\nmomglo: Moments from model, global stage\nfloc: Objective function value in local stage, sorted in increasing order\nxloc: Parameter combinations checked in local stage, sorted according to objective function value\nmomloc: Moments from model, local stage\nconv: Logical, if true convergence criterion at minimum is satisfied in the local stage\n\n\n\n\n\n","category":"type"},{"location":"fragments/estimation/#Global-stage","page":"Estimation","title":"Global stage","text":"","category":"section"},{"location":"fragments/estimation/#Local-stage","page":"Estimation","title":"Local stage","text":"","category":"section"},{"location":"fragments/estimation/#Comparison-with-other-algorithms","page":"Estimation","title":"Comparison with other algorithms","text":"","category":"section"},{"location":"fragments/estimation/#Multithreading-and-multiprocessing","page":"Estimation","title":"Multithreading and multiprocessing","text":"","category":"section"},{"location":"fragments/estimation/#Locally","page":"Estimation","title":"Locally","text":"","category":"section"},{"location":"fragments/estimation/#Cluster","page":"Estimation","title":"Cluster","text":"","category":"section"},{"location":"fragments/estimation/#Two-step-estimation","page":"Estimation","title":"Two-step estimation","text":"","category":"section"},{"location":"fragments/output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"fragments/output/","page":"Output","title":"Output","text":"Here describe the routines already provided to produce some graphs and tables with estimation results.","category":"page"},{"location":"fragments/output/#Figures","page":"Output","title":"Figures","text":"","category":"section"},{"location":"fragments/output/#Tables","page":"Output","title":"Tables","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"References are ruined on purpose, fix when they point somewhere","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Description. This package allows performing Method of Moments estimation (Generalized and Simulated).   It comprises three files which are not model-specific and are used in all applications and model-specific files. See below for more details.","category":"page"},{"location":"fragments/README/#Routine-files","page":"-","title":"Routine files","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"There are three files which are not model-specific and which are used in all applications:","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"SMMGMMestimation: contains structures and functions to perform the estimation;\nSMMGMMinference: contains functions to perform inference and diagnostics;\nSMMGMMoutput: contains structures and functions to produce tables and figures to display the estimation results.","category":"page"},{"location":"fragments/README/#1.-SMM*GMM*estimation","page":"-","title":"1. SMMGMMestimation","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"This is the core file performing the estimation routine. To describe the procedure let's introduce some useful notation:","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"x\n: array of data; \ntheta\n: array containing K parameters to be estimated;\ng(x theta)\n: array of M moment conditions, function of data and parameters, in the form g(x theta)=0;\nW\n: weighting matrix for the moment conditions with dimension M times M; \ng^primeWg\n: objective function to be minimized;\nS=mathbbEg(x theta)g(x theta)^prime\n: covariance matrix of the moments;\nG\n: matrix with the derivatives of the moment conditions with respect to theta with dimension M times K;\nHat over quantity: identifies estimators.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Note: identification requires M geq K.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"The estimation algorithm in the function [estimation] includes a global and a local stage in its most general form. Nevertheless, the code is flexible enough to allow performing only one of the two stages at a time. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Global stage. In the global stage (see [matchmom]) a Sobol sequence is generated on the parameter space defined by theta. The objective function is evaluated at each combination of parameters in the sequence. If only the global stage is performed, the best (in terms of lowest value of the objective function) combination of parameters is returned as the minimizer. Else, the best points (the number can be specified by the user) are used as starting guesses for the local stage. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Note: it is important that the number of global points evaluated is large, so that all the areas of the parameter space are searched well enough. This is especially true if the objective function is not well-behaved.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Local stage. The most promising candidates found in the global stage are then used as starting points for a local stage (see [opt_loc!]), in which the Nelder-Mead algorithm is used to find the minimum of the objective function. If only the local stage is performed, the initial guess can be supplied by the user. The global minimizer is then the best point among the values returned at the end of the local minimization routine at each tried starting guess.     ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"The file also contains a function [two_stage_estimation] to perform two-step GMM estimation. In the first step estimation is performed with a default weighting matrix. Parametric bootstrap (described in the next section) then allows to get the updated efficient weighting matrix (under the assumption that the model and estimated parameters are correct). The latter is then used as weighting matrix for estimation in the second step.","category":"page"},{"location":"fragments/README/#2.-SMM*GMM*inference","page":"-","title":"2. SMMGMMinference","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"This file contains functions to perform diagnostics and inference on the estimation results. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Diagnostics. In order to check that a minimum is achieved, the function [marginal_fobj] evaluates the objective function at points around the estimated parameter hattheta in one dimension at a time (see below for functions to plot this check) and saves the results in an array.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Parametric bootstrap. In order to gauge how precisely the targeted moments are estimated in the original data, a function [param_bootstrap] to perform parametric bootstrap is provided. Specifically, assuming model and estimated parameters are correct, alternative samples are simulated - with the same size as the original sample data sample - and, for each sample, an alternative vector of moments to match is computed. Then, for every alternative moment vector, the estimation procedure (local stage) is repeated. The resulting distribution of estimated parameters can be used to obtain the bootstrap confidence intervals. To check that the chosen seed does not influence the results (in which case it is recommended to restart the whole estimation with bigger simulation sizes), this procedure can optionally be repeated with several seeds.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Standard errors. The asymptotic variance [sandwich_matrix] of the parameter estimates has the usual sandwich form: (G^prime W G)^-1 G^prime W S W G(G^prime W G)^-1. hatG can is computed numerically at the estimated parameter value hattheta with the function [Qmatrix]. W is the weighting matrix used in estimation. Under the assumptions of the parametric bootstrap, there are two sources of variation in the parameter estimates: variation in the simulated sample for a given seed and across seeds. The parametric bootstrap procedure just outlined returns a distribution of the parameter estimates that considers exactly these two factors. Thus, the covariance matrix of the simulated moments is a consistent estimator for S and, after having been computed by the function [Omega_boots], it is used as hatS. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"Note: If the model is just identified or if hatW is a consistent estimator of S^-1 then the variance simplifies to (G^prime S^-1 G)^-1. The latter happens, for instance, when hatW is the efficient weighting matrix obtained in the two-stage estimation procedure or, in the parametric bootstrap case just described when hatW is set to the inverse of the consistent estimator of S.  ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"J-test. A function [Jtest] to test over-identifying restriction is provided. The J-statistic is defined as nhatg^primehatWhatg where hatW is a consistent estimator of S^-1, hatg a consistent estimator of the moment conditions and n is the sample size. Under the null J rightarrow_d chi^2_M-K.  ","category":"page"},{"location":"fragments/README/#3.-SMM*GMM*output","page":"-","title":"3. SMMGMMoutput","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"This file contains functions to organize the estimation results and to perform some sanity checks on them. More specifically, the following figures and tables can be generated: ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"[fsanity]: figure plotting the estimated parameters in every trial of the global or local stage in increasing order with respect to the objective function value obtained. If the found optimum is stable, then the estimated parameter values should not vary much, especially for the trials that achieved objective function values close to the minimum.\n[fmarg]: figure plotting the how the objective function varies when marginally moving the estimated parameter in one dimension at a time. If the optimum is a minimum, then the graphs should show that the objective function is minimized at that point.\n[fbootstrap]: figure showing the histogram of parameter estimates obtained in each bootstrap iteration. \n[plotmoms]: figure comparing the moments in the data and in the model (at the estimated parameter values). \n[tableest]: table with parameter estimates, optionally including bootstrap SE.\n[tablemoms]: table comparing the moments in the data and in the model (at the estimated parameter values), optionally including bootstrap SE.","category":"page"},{"location":"fragments/README/#Model-specific-files","page":"-","title":"Model-specific files","text":"","category":"section"},{"location":"fragments/README/","page":"-","title":"-","text":"This section describes the general format for model-specific files so that they can be used by the files performing the estimation routine. ","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"In general, the framework is flexible to accomodate any user-defined model. However, the following model-specific files should be included (as they are called in the general estimation routine):","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"[EstimationMode]: type for model to be estimated.\n[InnerAuxStructure]: type for the auxiliary structures to be initialized.\n[defaultInnerAuxStructure]: sets up default auxiliary object for computing model moments.\n[default_weight_matrix]: sets up default weighting matrix to compute the objective function.\n[datamoments]: computes moments from the data.\n[parambounds]: return parameter labels and ranges.\n[obj_mom]: computes moments in model under a given parameter guess.\n[mdiff]: computes deviation of model moments from data moments.\n[momentnames]: returns the full names of the moments, used for organising results.\n[mean_moments]: computes mean of moments, used for bootstrapping.","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"In addition, the following can also be model-specific:","category":"page"},{"location":"fragments/README/","page":"-","title":"-","text":"[indexvector]: if the default of having all model parameters estimated should be changed.\n[ftypemom]: if not having model-specific default moments to be estimated should be changed.\n[plotmoms]: if the default of having an empty graph to compare moments in the model and data should be changed.","category":"page"},{"location":"examples/#Example:-Estimating-an-AR(1)-process-with-noise","page":"Example","title":"Example: Estimating an AR(1) process with noise","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"Consider a stochastic process that is a sum of an AR(1) process and a white noise as follows:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"beginalign*\ny_it = z_it + nu_it\nz_it = rho cdot z_it-1 + varepsilon_it\nendalign*","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"where","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":" varepsilon_it sim mathcalN(0sigma_varepsilon^2) qquad  nu_it sim mathcalN(0sigma_nu^2)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"are i.i.d. shocks. The aim is to estimate parameters (rho sigma_varepsilon sigma_nu) based on a set of moments textVar(y_t) textCov(y_t y_t-1) textCov(y_t y_t-2) computed from an observed sample of y_its.","category":"page"},{"location":"examples/#Setting-up-the-problem","page":"Example","title":"Setting up the problem","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"First, one needs to define an estimation mode:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using MomentMatching # hide\nstruct AR1Estimation <: EstimationMode \n    \"mode-dependent prefix of filenames used for saving estimation results\"\n    filename::String\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"During the estimation, one needs to evaluate the objective function for each parameter guesses. Passing invariant parameters to the objective function is possible via defining an auxiliary structure which has to be a subtype of AuxiliaryParameters. One also needs to write a corresponding function to generate a default auxiliary structure as shown below. In this case, we pass the dimensions of the simulated sample.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"struct AR1AuxPar{T<:Integer} <: AuxiliaryParameters\n    \"sample size of simulation\"\n    Nsim::T\n    \"number of time periods to simulate\"\n    Tsim::T\n    \"number of periods to discard for moment evaluation \"\n    Tdis::T\nend\n\nAuxiliaryParameters(mode::AR1Estimation, modelname::String) = AR1AuxPar(10000, 200, 100)\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"It is crucial that the same set of shocks are used during the parameter estimation, as otherwise convergence cannot be achieved in the local minimization phase. (The sensitivity of results to different draws of shocks can be checked via bootstrapping, as explained later in the Inference section.) This is again done by defining an appropriate subtype of an existing abstract type and a function generating a default container of shocks. In this case, one needs to draw a normal shock for varepsilon and nu for each t and n.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"struct AR1PreShocks{S<:AbstractFloat} <: PredrawnShocks\n    \"preallocated array for persistent shocks\"\n    ϵs::Array{S,2}\n    \"preallocated array for transitory shocks\"\n    νs::Array{S,2}\nend\n\nfunction PredrawnShocks(mode::AR1Estimation, modelname::String, typemom::String,\n aux::AuxiliaryParameters)\n    return AR1PreShocks(randn(aux.Nsim, aux.Tsim),\n        randn(aux.Nsim, aux.Tsim))\nend\n\nnothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"In order to compute the necessary moments of large samples, one often needs to populate large arrays with realized values(in our case, of y_its). Creating separate containers for each guess for the parameter vector would be very costly, so instead this is done once before starting the estimation, and the data contained within will be repeatedly overwritten. (Note that when performing an estimation via parallel computing, these containers are internally generated separately for each thread, and hence data race is avoided.) In this example, we will compute cross-sectional moments in each time period and take their time-average in the final step. Therefore, we need to keep track of z and y (together its first and second lags) and the already computed moments. Defining the structure of preallocated data follows a similar logic as the previous steps.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"struct AR1PrealCont{S<:AbstractFloat} <: PreallocatedContainers\n    z::Vector{S}\n    y::Vector{S}\n    ylag1::Vector{S}\n    ylag2::Vector{S}\n    mat::Array{S,2}\nend\n\nfunction PreallocatedContainers(mode::AR1Estimation, modelname::String, typemom::String,\n aux::AuxiliaryParameters)\n\n    z = Vector{Float64}(undef, aux.Nsim)\n    y = Vector{Float64}(undef, aux.Nsim)\n    ylag1 = Vector{Float64}(undef, aux.Nsim)\n    ylag2 = Vector{Float64}(undef, aux.Nsim)\n\n    mat = Array{Float64}(undef, 3, aux.Tsim) # one row for each moment\n\n    return AR1PrealCont(z, y, ylag1, ylag2, mat)\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Now we are in the position of constructing the objective function. This is done via writing a method for MomentMatching.obj_mom!, specializing it on the subtype AR1Estimation created before.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using Statistics\nfunction MomentMatching.obj_mom!(mom::AbstractVector, momnorm::AbstractVector,\n mode::AR1Estimation, x::Array{Float64,1}, modelname::String, typemom::String,\n  aux::AuxiliaryParameters, presh::PredrawnShocks, preal::PreallocatedContainers;\n   saving_model::Bool=false, filename::String=\"\")\n    (ρ, σϵ, σν) = x\n\n    for n in 1:aux.Nsim\n        preal.z[n] = 0.0\n    end\n    for t in 1:aux.Tsim\n        for n in 1:aux.Nsim\n            preal.z[n] = ρ * preal.z[n] + σϵ * presh.ϵs[n, t]\n            preal.y[n] = preal.z[n] + σν * presh.νs[n, t]\n        end\n        if t > 2\n            preal.mat[3, t] = cov(preal.y, preal.ylag2)\n            copy!(preal.ylag2, preal.ylag1)\n        end\n        if t > 1\n            preal.mat[2, t] = cov(preal.y, preal.ylag1)\n            copy!(preal.ylag1, preal.y)\n        end\n        preal.mat[1, t] = var(preal.y)\n        copy!(preal.ylag1, preal.y)\n    end\n\n    mom[1] = mean(@view preal.mat[1, aux.Tdis:end])\n    momnorm[1] = mom[1]\n\n    mom[2] = mean(@view preal.mat[2, aux.Tdis:end])\n    momnorm[2] = mom[2]\n\n    mom[3] = mean(@view preal.mat[3, aux.Tdis:end])\n    momnorm[3] = mom[3]\n\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"We give the names and ranges of the targeted parameters by writing a method of parambounds. During the global phase of the estimation, the region within 'global' bounds is searched. Violating 'hard' bounds during the local phase induces a penalty to redirect the algorithm towards the allowed range.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"function MomentMatching.parambounds(mode::AR1Estimation)\n    full_labels    = [ \"ρ\",  \"σϵ\",  \"σν\"]\n    full_lb_hard   = [ 0.0,   0.0,  0.0 ]\n    full_lb_global = [ 0.0,   0.0,  0.0 ]\n    full_ub_global = [ 1.0,   1.0,  1.0 ]\n    full_ub_hard   = [ 1.0,   Inf,  Inf ]\n    return full_labels, full_lb_hard, full_lb_global, full_ub_global, full_ub_hard\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Next, we specify which moments are targeted during the estimation. In an actual application, this function would most likely read in values from a dataset, but here we just give three arbitrary numbers for each moments.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"function MomentMatching.datamoments(mode::AR1Estimation, typemom::String)\n    momtrue = [0.8, 0.45, 0.4] # made up numbers\n\n    mmomtrue = deepcopy(momtrue)\n\n    return hcat(momtrue, mmomtrue)\nend","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Finally, we name the targeted moments. The momentnames function has to return a DataFrame with two columns, where one targeted moment corresponds to one row. If the two moments have coinciding values in the first column, the corresponding results will be visualized together, as shown in section Estimation.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using DataFrames\nfunction MomentMatching.momentnames(mode::AR1Estimation, typemom::String)\n    moments = fill(\"Cov(y_t,y_t-j)\", 3)\n    lags = string.(0:2)\n    return DataFrame(Moment=moments, Lags=lags)\nend","category":"page"},{"location":"examples/#Example.Estimation","page":"Example","title":"Estimation","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"After defining an estimation setup and a structure supplying numerical settings, one can perform the estimation as follows. After checking 100 points in the global phase, a local minimization takes place using the Nelder-Mead algorithm, stated from the 10 global points with the lowest objective function values.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using OptimizationOptimJL\nsetup = EstimationSetup(AR1Estimation(\"ar1estim\"), \"\", \"\")\n\nnpest = NumParMM(setup; Nglo=100, Nloc=10,\n local_opt_settings = (algorithm = NelderMead(), maxtime = 30.0))\n\nest = estimation(setup; npmm=npest, saving=false); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The estimated parameters can be displayed as follows:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"tableest(setup, est)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The match with targeted moments can either be displayed as a table","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"tablemoms(setup, est)","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"or visualized on a figure:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"using Plots\nfmoms(setup, est)\nsavefig(\"fmoms.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"As in this case 3 parameters were estimated based on 3 moments (and hence parameters are exactly identified), the resulting match is very close.","category":"page"},{"location":"examples/#Diagnostics","page":"Example","title":"Diagnostics","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"When the objective function is highly non-linear, it is in general difficult to know if the obtained parameter estimate indeed corresponds to a global minimizer. One concern would be that the obtained local optimum is 'too local', i.e. its basin of attraction is too narrow. In this case the local optimum would be very sensitive to the respective initial point. To judge the accuracy of the estimated parameter vector, two heuristic methods are available in this package.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"First, it is possible to visualize how the objective function depends on varying the parameter estimates one-at-a-time (keeping the other parameters constant), around the best point.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"marg = marginal_fobj(setup, est, 17, fill(0.1, 3))\nfmarg(setup, est, marg)\nsavefig(\"fmarg.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Second, one can visualize how sensitive the corresponding parameter values are to the rank of the corresponding global or local point, with respect to their objective function values. This is informative on the sufficient number of global and local points.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Output from the global stage is available via the global keyword.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"fsanity(setup, est, glob = true)\nsavefig(\"fsanity_glo.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"By default, results from the local stage are shown.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"fsanity(setup, est)\nsavefig(\"fsanity_loc.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"examples/#Inference","page":"Example","title":"Inference","text":"","category":"section"},{"location":"examples/#Parametric-Bootstrap","page":"Example","title":"Parametric Bootstrap","text":"","category":"section"},{"location":"examples/","page":"Example","title":"Example","text":"Even if the model is correctly specified, there are two reasons why parameters are estimated with an error:","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"The targeted population moments are obtained from a finite sample.\nIf evaluating the objecting function involves uncertainty, the whole estimation procedure is conducted with one particular draw of shocks. This makes results potentially sensitive to this specific realization of shocks.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"One can gauge the joint effect of these forces on the precision of the estimates via parametric bootstrapping. ","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"First, using the obtained parameter estimates, N_sample independent samples are created to mimic the uncertainty in the data generating process. The targeted moments are then computed from each of these samples. Note that the size of the simulated samples have to coincide with the actual data sample which was used to compute the data moments.\nSecond, if computing the objective function involves random draws, N_seed number of different shocks are draws.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Then for each pair of alternative moments and seeds, the local stage of the estimation is repeated starting from the best local point of the original estimation. The distribution of the resulting N_sample cdot N_seed new estimates can then be used to generate confidence intervals.","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"Tdis = 20 # burn in\nTdata = 40 # true data length\nNdata = 500 # true sample size\nNsample = 15 # number of samples used for bootstrap\nNseed = 15 # number of shock simulations used for bootstrap\nauxmomsim = AR1AuxPar(Ndata, Tdata + Tdis, Tdis)\nboot = param_bootstrap_result(setup, est, auxmomsim, Nseed, Nsample, Ndata, saving=false)\n\nfbootstrap(setup, est, boot)\nsavefig(\"fbootstrap.svg\"); nothing # hide","category":"page"},{"location":"examples/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"#MomentMatching.jl","page":"Home","title":"MomentMatching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a unified framework to perform Method of Moments (Generalized and Simulated) parameter estimation for economic models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generalized Method of Moments (GMM) estimation[1] consists in finding the vector of parameters theta that solves the following system of equations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbbEleftgleft(thetaright)right=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"where g is a vector of functions representing moment conditions derived from a model depending on the vector of parameters to be estimated theta. When moment conditions are computed via simulation, the above procedure is called Simulated Method of Moments (SMM) estimation.[2]","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the system is over-identified (g has higher dimensionality than theta), solving such an equation exactly is in general not possible. Instead, the goal becomes finding the vector of parameters theta that minimizes the following objective function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g(theta)^prime W g(theta)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where W is a weighting matrix.[3] ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims at providing a general toolbox for such estimation exercises, irrespective of what model one wants to estimate. Ready-to-use tools are provided to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"estimate theta via a combination of global search and a local optimization routine;\nperform diagnostic checks on the results; \ndo statistical inference and \nproduce tables and figures displaying the estimation results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package was built having in mind three key features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ease of use: The user just needs to write a wrapper around her code conformable with the estimation routines and set the algorithm options before running the main estimation function. This is an easy task even if the model code was not written specifically to be compatible with this package. \nFlexibility: Routines can be used for the estimation of any model. Estimation of robustness checks and alternative model specifications is convenient.\nParallelization: Multithreading and multiprocessing (also combined) are supported, both locally and on a cluster.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MomentMatching\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package use the command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MomentMatching","category":"page"},{"location":"#Authors-and-citing","page":"Home","title":"Authors and citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gualtiero Azzalini (Stockholm School of Economics) \nZoltán Rácz (Stockholm School of Economics)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please consider citing the package if you use MomentMatching in your research:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{MomentMatching.jl,\n  title = {{MomentMatching.jl}: Parameter Estimation of Economic Models via Moment Matching Methods in Julia},\n  author = {Azzalini, Gualtiero and Rácz, Zoltán},\n  year = {2024},\n  howpublished = {\\url{https://github.com/ZoltanRacz/MomentMatching.jl}}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Hansen, L. P. (1982). Large Sample Properties of Generalized Method of Moments Estimators. Econometrica, 50(4), 1029–1054. https://doi.org/10.2307/1912775.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: McFadden, D. (1989). A Method of Simulated Moments for Estimation of Discrete Response Models Without Numerical Integration. Econometrica, 57(5), 995–1026. https://doi.org/10.2307/1913621.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Clearly, this procedure can also be used in the just-identified case and it should deliver the same result as the one obtained when using routines to solve system of equations.","category":"page"},{"location":"fragments/inference/#Inference-and-Diagnostics","page":"Inference and Diagnostics","title":"Inference and Diagnostics","text":"","category":"section"},{"location":"fragments/inference/#Asymptotics","page":"Inference and Diagnostics","title":"Asymptotics","text":"","category":"section"},{"location":"fragments/inference/#Bootstrap","page":"Inference and Diagnostics","title":"Bootstrap","text":"","category":"section"},{"location":"fragments/inference/#Parametric","page":"Inference and Diagnostics","title":"Parametric","text":"","category":"section"},{"location":"fragments/inference/#Non-parametric","page":"Inference and Diagnostics","title":"Non-parametric","text":"","category":"section"},{"location":"fragments/inference/#Testing-over-identifying-restrictions","page":"Inference and Diagnostics","title":"Testing over-identifying restrictions","text":"","category":"section"},{"location":"fragments/inference/#Diagnostics","page":"Inference and Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"fragments/index_longer/#MomentMatching.jl","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"","category":"section"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Generalized Method of Moments (GMM) estimation[1] consists in finding the vector of parameters theta that solves the following system of equations:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"mathbbEleftgleft(thetaright)right=0","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"where g is a vector of functions representing moment conditions derived from a model depending on the vector of parameters to be estimated theta. When moment conditions are computed via simulation, the above procedure is called Simulated Method of Moments (SMM) estimation.[2]","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Letting k be the dimensionality of theta and m that of g, if:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"mk, then the system does not have a solution;\nm=k, then the system is just-identified and there is a unique solution;\nmk, then the system is over-identified and more than one solution is possible.","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"In the just-identified case, common procedures to solve system of equations can be used. However, when the system is over-identified, this approach is not possible. Instead, the goal becomes finding the vector of parameters theta that minimizes the following objective function:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"g(theta)^prime W g(theta)","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"where W is a weighting matrix.[3] ","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"This package provides a series of numerical routines to perform Method of Moments estimation (Generalized and Simulated), i.e., find an estimate of the vector theta (see section Estimation). It also contains ready-to-use tools (i) to check the quality of the estimation results and to do statistical inference (see section Inference and Diagnostics) and (ii) to produce tables and figures displaying estimation results (see section Output).","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"The package was built having in mind three key features:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Flexibility: routines can be used for estimation of any model;\nParallelization: multithreading and multiprocessing (also combined) are supported, both locally and on a cluster;\nEase of use: the user just needs to write her model in a way conformable with the estimation routines and set the algorithm options before running the main estimation function.","category":"page"},{"location":"fragments/index_longer/#Installation","page":"MomentMatching.jl","title":"Installation","text":"","category":"section"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"To install the package run:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"using Pkg\nPkg.add(\"MomentMatching\")","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"To load the package use the command:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"using MomentMatching","category":"page"},{"location":"fragments/index_longer/#Authors-and-citing","page":"MomentMatching.jl","title":"Authors and citing","text":"","category":"section"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Gualtiero Azzalini (Stockholm School of Economics) \nZoltán Rácz (Stockholm School of Economics)","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"Please consider citing the package if you use MomentMatching in your research:","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"@misc{MomentMatching.jl,\n  title = {{MomentMatching.jl}: Parameter Estimation of Economic Models via Moment Matching Methods in Julia},\n  author = {Azzalini, Gualtiero and Rácz, Zoltán},\n  year = {2024},\n  howpublished = {\\url{https://github.com/ZoltanRacz/MomentMatching.jl}}\n}","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"[1]: Hansen, L. P. (1982). Large Sample Properties of Generalized Method of Moments Estimators. Econometrica, 50(4), 1029–1054. https://doi.org/10.2307/1912775.","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"[2]: McFadden, D. (1989). A Method of Simulated Moments for Estimation of Discrete Response Models Without Numerical Integration. Econometrica, 57(5), 995–1026. https://doi.org/10.2307/1913621.","category":"page"},{"location":"fragments/index_longer/","page":"MomentMatching.jl","title":"MomentMatching.jl","text":"[3]: Clearly, this procedure can also be used in the just-identified case and it should deliver the same result as the one obtained when using routines to solve system of equations.","category":"page"}]
}
